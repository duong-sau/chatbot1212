answer,intent,answer_index,intent_index,first
"<classify1 id=""0""><h2 id=""partitioned-analysis-for-multi-gene-alignments"">Partitioned analysis for multi-gene alignments</h2><div class=""hline""></div><p>If you used partition model in a publication please cite:</p><blockquote><p><strong>O. Chernomor, A. von Haeseler, and B.Q. Minh</strong> (2016) Terrace aware data structure for phylogenomic inference from supermatrices. <em>Syst. Biol.</em>, 65:997-1008. <a href=""https://doi.org/10.1093/sysbio/syw037"">https://doi.org/10.1093/sysbio/syw037</a></p></blockquote><p>In the partition model, you can specify a substitution model for each gene/character set. IQ-TREE will then estimate the model parameters separately for every partition. Moreover, IQ-TREE provides edge-linked or edge-unlinked branch lengths between partitions:</p><ul><li><code>-q partition_file</code>: all partitions share the same set of branch lengths (like <code>-q</code> option of RAxML).</li><li><code>-p partition_file</code> (<code>-spp</code> in version 1.x): like above but allowing each partition to have its own evolution rate.</li><li><code>-Q partition_file</code> (<code>-sp</code> in version 1.x): each partition has its own set of branch lengths (like combination of <code>-q</code> and <code>-M</code> options in RAxML) to account for, e.g. <em>heterotachy</em> (<a href=""http://mbe.oxfordjournals.org/content/19/1/1.full"">Lopez et al., 2002</a>).</li></ul><blockquote><p><strong>NOTE</strong>: <code>-p</code> is recommended for typical analysis. <code>-q</code> is unrealistic and <code>-Q</code> is very parameter-rich. One can also perform all three analyses and compare e.g. the BIC scores to determine the best-fit partition model.</p></blockquote><p>IQ-TREE supports RAxML-style and NEXUS partition input file. The RAxML-style partition file may look like:</p><pre><code>DNA, part1 = 1-100
DNA, part2 = 101-384
</code></pre><p>If your partition file is called <code>example.partitions</code>, the partition analysis can be run with:</p><pre><code>iqtree -s example.phy -p example.partitions -m GTR+I+G
# for version 1.x change -p to -spp
</code></pre><p>Note that using RAxML-style partition file, all partitions will use the same rate heterogeneity model given in <code>-m</code> option (<code>+I+G</code> in this example). If you want to specify, say, <code>+G</code> for the first partition and <code>+I+G</code> for the second partition, then you need to create the more flexible NEXUS partition file. This file contains a <code>SETS</code> block with <code>CharSet</code> and <code>CharPartition</code> commands to specify individual genes and the partition, respectively. For example:</p><pre><code>#nexus
begin sets;
    charset part1 = 1-100;
    charset part2 = 101-384;
    charpartition mine = HKY+G:part1, GTR+I+G:part2;
end;
</code></pre><p>If your NEXUS file is called <code>example.nex</code>, then you can use the option <code>-p</code> to input the file as following:</p><pre><code>iqtree -s example.phy -p example.nex
# for version 1.x change -p to -spp
</code></pre><p>Here, IQ-TREE partitions the alignment <code>example.phy</code> into 2 sub-alignments named <code>part1</code> and <code>part2</code> containing sites (columns) 1-100 and 101-384, respectively. Moreover, IQ-TREE applies the subtitution models <code>HKY+G</code> and <code>GTR+I+G</code> to <code>part1</code> and <code>part2</code>, respectively. Substitution model parameters and trees with branch lengths can be found in the result file <code>example.nex.iqtree</code>.</p><p>Moreover, the <code>CharSet</code> command allows to specify non-consecutive sites with e.g.:</p><pre><code>charset part1 = 1-100 200-384;
</code></pre><p>That means, <code>part1</code> contains sites 1-100 and 200-384 of the alignment. Another example is:</p><pre><code>charset part1 = 1-100\3;
</code></pre><p>for extracting sites 1,4,7,…,100 from the alignment. This is useful for getting codon positions from the protein-coding alignment.</p></classify1>",Partitioned analysis for multi-gene alignments,1.0,1.0,If you used partition model in a publication please cite:
"<classify1 id=""1""><h2 id=""partitioned-analysis-with-mixed-data"">Partitioned analysis with mixed data</h2><div class=""hline""></div><p>IQ-TREE also allows combining sub-alignments from different alignment files, which is helpful if you want to combine mixed data (e.g. DNA and protein) in a single analysis. Here is an example for mixing DNA, protein and codon models:</p><pre><code>#nexus
begin sets;
    charset part1 = dna.phy: 1-100 201-300;
    charset part2 = dna.phy: 101-200;
    charset part3 = prot.phy: 1-400;
    charset part4 = prot.phy: 401-600;
    charset part5 = codon.phy:CODON, *;
    charpartition mine = HKY:part1, GTR+G:part2, LG+G:part3, WAG+I+G:part4, GY:part5;
end;
</code></pre><p>Here, <code>part1</code> and <code>part2</code> contain sub-alignments from alignment file <code>dna.phy</code>, whereas <code>part3</code> and <code>part4</code> are loaded from alignment file <code>prot.phy</code> and <code>part5</code> from <code>codon.phy</code>. The <code>:</code> is needed to separate the alignment file name and site specification. Note that, for convenience <code>*</code> in <code>part5</code> specification means that <code>part5</code> corresponds to the entire alignment <code>codon.phy</code>.</p><blockquote class=""tip""><p><strong>TIP</strong>: For <code>part5</code> the <code>CODON</code> keyword is specified so that IQ-TREE will apply a codon model. Moreover, this implicitly assumes the standard genetic code. If you want to use another genetic code, append <code>CODON</code> with the <a href=""http://www.iqtree.org/doc/Substitution-Models#codon-models"">code ID described here</a></p></blockquote><p>Because the alignment file names are now specified in this NEXUS file, you can omit the <code>-s</code> option:</p><pre><code>iqtree -p example.nex
# for version 1.x change -p to -spp
</code></pre><p>Note that <code>aln.phy</code> and <code>prot.phy</code> does not need to contain the same set of sequences. For instance, if some sequence occurs in <code>aln.phy</code> but not in <code>prot.phy</code>, IQ-TREE will treat the corresponding parts of sequence in <code>prot.phy</code> as missing data. For your convenience IQ-TREE writes the concatenated alignment into the file <code>example.nex.conaln</code>.</p></classify1>",Partitioned analysis with mixed data,2.0,2.0,"IQ-TREE also allows combining sub-alignments from different alignment files, which is helpful if you want to combine mixed data (e.g. DNA and protein) in a single analysis. Here is an example for mixing DNA, protein and codon models:"
"<classify1 id=""2""><h2 id=""choosing-the-right-partitioning-scheme"">Choosing the right partitioning scheme</h2><div class=""hline""></div><p>ModelFinder implements a greedy strategy (<a href=""https://doi.org/10.1093/molbev/mss020"">Lanfear et al., 2012</a>) that starts with the full partition model and subsequentially merges two genes until the model fit does not increase any further:</p><pre><code>iqtree -s example.phy -p example.nex -m MFP+MERGE
# for version 1.x change -p to -spp
</code></pre><p>Note that this command considers the FreeRate heterogeneity model (see <a href=""http://www.iqtree.org/doc/Tutorial#choosing-the-right-substitution-model"">model selection tutorial</a>). If you want to resemble PartitionFinder by just considering the invariable site and Gamma rate heterogeneity (thus saving computation times), then run:</p><pre><code>iqtree -s example.phy -p example.nex -m TESTMERGE
# for version 1.x change -p to -spp
</code></pre><p>After ModelFinder found the best partition, IQ-TREE will immediately start the tree reconstruction under the best-fit partition model. Sometimes you only want to find the best-fit partition model without doing tree reconstruction, then run:</p><pre><code>iqtree -s example.phy -p example.nex -m MF+MERGE
# for version 1.x change -p to -spp
</code></pre><p>To resemble PartitionFinder and save time:</p><pre><code>iqtree -s example.phy -p example.nex -m TESTMERGEONLY
# for version 1.x change -p to -spp
</code></pre><p>To reduce the computational burden IQ-TREE implements the <em>relaxed hierarchical clustering algorithm</em> (<a href=""https://doi.org/10.1186/1471-2148-14-82"">Lanfear et al., 2014</a>), which is invoked via <code>-rcluster</code> option:</p><pre><code>iqtree -s example.phy -p example.nex -m MF+MERGE -rcluster 10
# for version 1.x change -p to -spp
</code></pre><p>to only examine the top 10% partition merging schemes (similar to the <code>--rcluster-percent 10</code> option in PartitionFinder).</p></classify1>",Choosing the right partitioning scheme,3.0,3.0,"ModelFinder implements a greedy strategy (Lanfear et al., 2012) that starts with the full partition model and subsequentially merges two genes until the model fit does not increase any further:"
"<classify1 id=""3""><h2 id=""ultrafast-bootstrapping-with-partition-model"">Ultrafast bootstrapping with partition model</h2><div class=""hline""></div><p>IQ-TREE can perform the ultrafast bootstrap with partition models by e.g.,</p><pre><code>iqtree -s example.phy -p example.nex -B 1000
# for version 1.x change -p to -spp and -B to -bb
</code></pre><p>Here, IQ-TREE will resample the sites <em>within</em> partitions (i.e., the bootstrap replicates are generated per partition separately and then concatenated together). The same holds true if you do the standard nonparametric bootstrap.</p><p>IQ-TREE supports the partition-resampling strategy as suggested by (<a href=""https://doi.org/10.1073/pnas.051611498"">Nei et al., 2001</a>):</p><pre><code>iqtree -s example.phy -p example.nex -B 1000 --sampling GENE
# for version 1.x change -p to -spp and -B to -bb and --sampling to -bsam
</code></pre><p>to resample partitions instead of sites. Moreover, IQ-TREE allows an even more complicated strategy: resampling partitions and then sites within resampled partitions (<a href=""https://doi.org/10.1002/jez.b.21026"">Gadagkar et al., 2005</a>; <a href=""https://doi.org/10.1073/pnas.0408313102"">Seo et al., 2005</a>). This may help to reduce false positives (i.e. wrong branch receiving 100% support):</p><pre><code>iqtree -s example.phy -p example.nex -B 1000 --sampling GENESITE
# for version 1.x change -p to -spp and -B to -bb and --sampling to -bsam
</code></pre></classify1>",Ultrafast bootstrapping with partition model,4.0,4.0,"IQ-TREE can perform the ultrafast bootstrap with partition models by e.g.,"
"<classify1 id=""4""><h2 id=""constrained-tree-search"">Constrained tree search</h2><div class=""hline""></div><p>IQ-TREE supports constrained tree search via <code>-g</code> option, so that the resulting tree must obey a constraint tree topology. The constraint tree can be multifurcating and need not to contain all species. To illustrate, let’s return to the <a href=""http://www.iqtree.org/doc/Tutorial#first-running-example"">first running example</a>, where we want to force Human grouping with Seal whereas Cow with Whale. If you use the following constraint tree (NEWICK format):</p><pre><code>((Human,Seal),(Cow,Whale));
</code></pre><p>Save this to a file <code>example.constr0</code> and run:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -g example.constr0 --prefix example.constr0
# for version 1.x change --prefix to -pre
</code></pre><p>(We use a prefix in order not to overwrite output files of the previous run). The resulting part of the tree extracted from <code>example.constr0.iqtree</code> looks exactly like a normal unconstrained tree search:</p><pre><code>        +--------------Human
     +--|
     |  |  +------Seal
     |  +--|
     |     |  +-----Cow
     |     +--|
     |        +-------Whale
+----|
|    |         +---Mouse
|    +---------|
|              +------Rat
</code></pre><p>This is the correct behavior: although Human and Seal are not monophyletic, this tree indeed satisfies the constraint, because the induced subtree separates (Human,Seal) from (Cow,Whale). This comes from the fact that the tree is <em>unrooted</em>. If you want them to be sister groups, then you need to include <em>outgroup</em> taxa into the constraint tree. For example:</p><pre><code>((Human,Seal),(Cow,Whale),Mouse);
</code></pre><p>Save this to <code>example.constr1</code> and run:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -g example.constr1 --prefix example.constr1
# for version 1.x change --prefix to -pre
</code></pre><p>The resulting part of the tree is then:</p><pre><code>           +---------------Human
        +--|
        |  +------Seal
     +--|
     |  |  +-----Cow
     |  +--|
     |     +-------Whale
+----|
|    |         +---Mouse
|    +---------|
|              +------Rat
</code></pre><p>which shows the desired effect.</p><blockquote><p><strong>NOTE</strong>: While this option helps to enforce the tree based on prior knowledge, it is advised to always perform tree topology tests to make sure that the resulting constrained tree is NOT significantly worse than an unconstrained tree! See <a href=""http://www.iqtree.org/doc/Advanced-Tutorial#tree-topology-tests"">tree topology tests</a> and <a href=""http://www.iqtree.org/doc/Advanced-Tutorial#testing-constrained-tree"">testing constrained tree</a> below for a guide how to check this.</p></blockquote></classify1>",Constrained tree search,5.0,5.0,"IQ-TREE supports constrained tree search via -g option, so that the resulting tree must obey a constraint tree topology. The constraint tree can be multifurcating and need not to contain all species. To illustrate, let’s return to the first running example, where we want to force Human grouping with Seal whereas Cow with Whale. If you use the following constraint tree (NEWICK format):"
"<classify1 id=""5""><h2 id=""tree-topology-tests"">Tree topology tests</h2><div class=""hline""></div><p>IQ-TREE can compute log-likelihoods of a set of trees passed via the <code>-z</code> option:</p><pre><code>iqtree -s example.phy -z example.treels -m GTR+G
</code></pre><p>assuming that <code>example.treels</code> is an existing file containing a set of trees in NEWICK format. IQ-TREE first reconstructs an ML tree. Then, it will compute the log-likelihood of the trees in <code>example.treels</code> based on the estimated parameters done for the ML tree. <code>example.phy.iqtree</code> will have a section called <code>USER TREES</code> that lists the tree IDs and the corresponding log-likelihoods. The trees with optimized branch lengths can be found in <code>example.phy.treels.trees</code> If you only want to evaluate the trees without reconstructing the ML tree, you can run:</p><pre><code>iqtree -s example.phy -z example.treels -n 0
</code></pre><p>Here, the number of search iterations is set to 0 (<code>-n 0</code>), such that model parameters are quickly estimated from an initial parsimony tree, which is normally accurate enough for our purpose. If you, however, prefer to estimate model parameters based on a tree (e.g. reconstructed previously), use <code>-te &lt;treefile&gt;</code> option.</p><p>IQ-TREE also supports several tree topology tests using the RELL approximation (<a href=""https://doi.org/10.1007/BF02109483"">Kishino et al., 1990</a>). This includes bootstrap proportion (BP), Kishino-Hasegawa test (<a href=""https://doi.org/10.1007/BF02100115"">Kishino and Hasegawa, 1989</a>), Shimodaira-Hasegawa test (<a href=""https://doi.org/10.1093/oxfordjournals.molbev.a026201"">Shimodaira and Hasegawa, 1999</a>), expected likelihood weights (<a href=""https://doi.org/10.1098/rspb.2001.1862"">Strimmer and Rambaut, 2002</a>):</p><pre><code>iqtree -s example.phy -z example.treels -n 0 -zb 1000
</code></pre><p>Here, <code>-zb</code> specifies the number of RELL replicates, where 1000 is the recommended minimum number. The <code>USER TREES</code> section of <code>example.phy.iqtree</code> will list the results of BP, KH, SH, and ELW methods.</p><p>If you also want to perform the weighted KH and weighted SH tests, simply add <code>-zw</code> option:</p><pre><code>iqtree -s example.phy -z example.treels -n 0 -zb 1000 -zw
</code></pre><p>Starting with version 1.4.0 IQ-TREE supports approximately unbiased (AU) test (<a href=""https://doi.org/10.1080/10635150290069913"">Shimodaira, 2002</a>) via <code>-au</code> option:</p><pre><code>iqtree -s example.phy -z example.treels -n 0 -zb 1000 -zw -au
</code></pre><p>This will perform all above tests plus the AU test.</p><p>Finally, note that IQ-TREE will automatically detect duplicated tree topologies and omit them during the evaluation.</p><blockquote class=""tip""><p><strong>HINTS</strong>:</p><ul><li><p>The KH, SH and AU tests return p-values, thus a tree is rejected if its p-value &lt; 0.05 (marked with a <code>-</code> sign).</p></li><li><p>bp-RELL and c-ELW return posterior weights which <em>are not p-value</em>. The weights sum up to 1 across the trees tested.</p></li><li><p>The KH test (<a href=""https://doi.org/10.1007/BF02100115"">Kishino and Hasegawa, 1989</a>) was designed to test 2 trees and thus has no correction for multiple testing. The SH test (<a href=""https://doi.org/10.1093/oxfordjournals.molbev.a026201"">Shimodaira and Hasegawa, 1999</a>) fixes this problem.</p></li><li><p>However, the SH test becomes too conservative (i.e., rejecting fewer trees than expected) when testing many trees. The AU test (<a href=""https://doi.org/10.1080/10635150290069913"">Shimodaira, 2002</a>) fixes this problem and is thus recommended as replacement for both KH and SH tests.</p></li></ul></blockquote></classify1>",Tree topology tests,6.0,6.0,IQ-TREE can compute log-likelihoods of a set of trees passed via the -z option:
"<classify1 id=""6""><h2 id=""testing-constrained-tree"">Testing constrained tree</h2><div class=""hline""></div><p>We now illustrate an example to use the AU test (see above) to test trees from unconstrained versus constrained search, which is helpful to know if a constrained search is sensible or not. Thus:</p><ol><li><p>Perform an unconstrained search:</p><pre><code> iqtree -s example.phy -m TIM2+I+G --prefix example.unconstr
 # for version 1.x change --prefix to -pre
</code></pre></li><li><p>Perform a constrained search, where <code>example.constr1</code> file contains: <code>((Human,Seal),(Cow,Whale),Mouse);</code>:</p><pre><code> iqtree -s example.phy -m TIM2+I+G -g example.constr1 --prefix example.constr1
 # for version 1.x change --prefix to -pre
</code></pre></li><li><p>Perform another constrained search, where <code>example.constr2</code> file contains <code>((Human,Cow,Whale),Seal,Mouse);</code>:</p><pre><code> iqtree -s example.phy -m TIM2+I+G -g example.constr2 --prefix example.constr2
 # for version 1.x change --prefix to -pre
</code></pre></li><li><p>Perform the last constrained search, where <code>example.constr3</code> file contains <code>((Human,Mouse),(Cow,Rat),Opossum);</code>:</p><pre><code> iqtree -s example.phy -m TIM2+I+G -g example.constr3 --prefix example.constr3
 # for version 1.x change --prefix to -pre
</code></pre></li><li><p>Concatenate all trees into a file:</p><pre><code> # for Linux or macOS
 cat example.unconstr.treefile example.constr1.treefile example.constr2.treefile example.constr3.treefile &gt; example.treels
    
 # for Windows
 type example.unconstr.treefile example.constr1.treefile example.constr2.treefile example.constr3.treefile &gt; example.treels
</code></pre></li><li><p>Test the set of trees:</p><pre><code> iqtree -s example.phy -m TIM2+I+G -z example.treels -n 0 -zb 1000 -au
</code></pre></li></ol><p>Now look at the resulting <code>.iqtree</code> file:</p><pre><code>USER TREES
----------

See example.phy.trees for trees with branch lengths.

Tree      logL    deltaL  bp-RELL    p-KH     p-SH    c-ELW     p-AU
-------------------------------------------------------------------------
  1   -21152.617   0.000  0.7110 + 0.7400 + 1.0000 + 0.6954 + 0.7939 + 
  2   -21156.802   4.185  0.2220 + 0.2600 + 0.5910 + 0.2288 + 0.3079 + 
  3   -21158.579   5.962  0.0670 + 0.1330 + 0.5130 + 0.0758 + 0.1452 + 
  4   -21339.596 186.980  0.0000 - 0.0000 - 0.0000 - 0.0000 - 0.0000 - 

deltaL  : logL difference from the maximal logl in the set.
bp-RELL : bootstrap proportion using RELL method (Kishino et al. 1990).
p-KH    : p-value of one sided Kishino-Hasegawa test (1989).
p-SH    : p-value of Shimodaira-Hasegawa test (2000).
c-ELW   : Expected Likelihood Weight (Strimmer &amp; Rambaut 2002).
p-AU    : p-value of approximately unbiased (AU) test (Shimodaira, 2002).

Plus signs denote the 95% confidence sets.
Minus signs denote significant exclusion.
All tests performed 1000 resamplings using the RELL method.
</code></pre><p>One sees that the AU test does not reject the first 3 trees (denoted by <code>+</code> sign below the <code>p-AU</code> column), whereas the last tree is significantly excluded (<code>-</code> sign). All other tests also agree with this. Therefore, groupings of <code>(Human,Mouse)</code> and <code>(Cow,Rat)</code> do not make sense. Whereas the phylogenetic position of <code>Seal</code> based on 3 first trees is still undecidable. This is in agreement with the SH-aLRT and ultrafast bootstrap supports <a href=""http://www.iqtree.org/doc/Tutorial#assessing-branch-supports-with-single-branch-tests"">done in the Tutorial</a>.</p></classify1>",Testing constrained tree,7.0,7.0,"We now illustrate an example to use the AU test (see above) to test trees from unconstrained versus constrained search, which is helpful to know if a constrained search is sensible or not. Thus:"
"<classify1 id=""7""><h2 id=""consensus-construction-and-bootstrap-value-assignment"">Consensus construction and bootstrap value assignment</h2><div class=""hline""></div><p>IQ-TREE can construct an extended majority-rule consensus tree from a set of trees written in NEWICK or NEXUS format (e.g., produced by MrBayes):</p><pre><code>iqtree -con mytrees
</code></pre><p>To build a majority-rule consensus tree, simply set the minimum support threshold to 0.5:</p><pre><code>iqtree -con mytrees -minsup 0.5
</code></pre><p>If you want to specify a burn-in (the number of beginning trees to ignore from the trees file), use <code>-bi</code> option:</p><pre><code>iqtree -con mytrees -minsup 0.5 -bi 100
</code></pre><p>to skip the first 100 trees in the file.</p><p>IQ-TREE can also compute a consensus network and print it into a NEXUS file by:</p><pre><code>iqtree -net mytrees
</code></pre><p>Finally, a useful feature is to read in an input tree and a set of trees, then IQ-TREE can assign the support value onto the input tree (number of times each branch in the input tree occurs in the set of trees). This option is useful if you want to compute the support values for an ML tree based on alternative topologies.</p><pre><code>iqtree -sup input_tree set_of_trees
</code></pre></classify1>",Consensus construction and bootstrap value assignment,8.0,8.0,"IQ-TREE can construct an extended majority-rule consensus tree from a set of trees written in NEWICK or NEXUS format (e.g., produced by MrBayes):"
"<classify1 id=""8""><h2 id=""user-defined-substitution-models"">User-defined substitution models</h2><div class=""hline""></div><p>Users can specify any DNA model using a 6-letter code that defines which rates should be equal. For example, <code>010010</code> corresponds to the HKY model and <code>012345</code> to the GTR model. In fact, IQ-TREE uses this specification internally to simplify the coding. The 6-letter code is specified via the <code>-m</code> option, e.g.:</p><pre><code>iqtree -s example.phy -m 010010+G
</code></pre><p>Moreover, with the <code>-m</code> option one can input a file which contains the 6 rates (A-C, A-G, A-T, C-G, C-T, G-T) and 4 base frequencies (A, C, G, T). For example:</p><pre><code>iqtree -s example.phy -m mymodel+G
</code></pre><p>where <code>mymodel</code> is a file containing the 10 entries described above, in the correct order. The entries can be seperated by either empty space(s) or newline character. One can even specify the rates within <code>-m</code> option by e.g.:</p><pre><code>iqtree -s example.phy -m 'TN{2.0,3.0}+G8{0.5}+I{0.15}'
</code></pre><p>That means, we use Tamura-Nei model with fixed transition-transversion rate ratio of 2.0 and purine/pyrimidine rate ratio of 3.0. Moreover, we use 8-category Gamma-distributed site rates with the shape parameter (alpha) equal to 0.5 and a proportion of invariable sites p-inv=0.15.</p><p>By default IQ-TREE computes empirical state frequencies from the alignment by counting, but one can also estimate the frequencies by maximum-likelihood with <code>+Fo</code> in the model name:</p><pre><code>iqtree -s example.phy -m GTR+G+Fo
</code></pre><p>For amino-acid alignments, IQ-TREE use the empirical frequencies specified in the model. If you want frequencies as counted from the alignment, use <code>+F</code>, for example:</p><pre><code>iqtree -s myprotein_alignment -m WAG+G+F
</code></pre><p>Note that all model specifications above can be used in the partition model NEXUS file.</p></classify1>",User-defined substitution models,9.0,9.0,"Users can specify any DNA model using a 6-letter code that defines which rates should be equal. For example, 010010 corresponds to the HKY model and 012345 to the GTR model. In fact, IQ-TREE uses this specification internally to simplify the coding. The 6-letter code is specified via the -m option, e.g.:"
"<classify1 id=""9""><h2 id=""inferring-site-specific-rates"">Inferring site-specific rates</h2><div class=""hline""></div><p>IQ-TREE allows to infer site-specific evolutionary rates if a <a href=""http://www.iqtree.org/doc/Substitution-Models#rate-heterogeneity-across-sites"">site-rate heterogeneity model such as Gamma or FreeRate</a> is the best model. Here, IQ-TREE will estimate model parameters and then apply an empirical Bayesian approach to assign site-rates as the mean over rate categories, weighted by the posterior probability of the site falling into each category. This approach is provided in IQ-TREE because such empirical Bayesian approach was shown to be most accurate (<a href=""https://doi.org/10.1093/molbev/msh194"">Mayrose et al., 2004</a>). An example run:</p><pre><code>iqtree -s example.phy --rate
# for version 1.x change --rate to -wsr
</code></pre><p>IQ-TREE will write an output file <code>example.phy.rate</code> that looks like:</p><pre><code>Site    Rate    Category        Categorized_rate
1       0.26625 2       0.24393
2       0.99345 3       0.81124
3       2.69275 4       2.91367
4       0.25822 2       0.24393
5       0.25822 2       0.24393
6       0.42589 2       0.24393
7       0.30194 2       0.24393
8       0.72790 3       0.81124
9       0.25822 2       0.24393
10      0.09177 1       0.03116
</code></pre><p>The 1st column is site index of the alignment (starting from 1), the 2nd column <code>Rate</code> shows the mean site-specific rate as explained above, and the 3rd and 4th columns show the category index and rate of the Gamma rate category with the highest probability for this site (1 for slow and 4 for fast rate).</p><p>The above run will perform a full tree search. To speed up you can use <code>-n 0</code> to only use a parsimony tree for site rate estimates. Or if you have already infered an ML tree, you can specify it to improve the rate estimate:</p><pre><code>iqtree -s example.phy -t ml.treefile -n 0 --rate 
# for version 1.x change --rate to -wsr
</code></pre><p>where <code>-t</code> is the option to input a fixed tree topology and <code>ml.treefile</code> is the ML tree reconstructed previously.</p><p>If you already know the best-fit model for the alignment, you can use specify it via <code>-m</code> option to omit model selection and hence speed it up:</p><pre><code>iqtree -s example.phy -m GTR+R10 -n 0 --rate 
# for version 1.x change --rate to -wsr
</code></pre><p>Finally, IQ-TREE 2 allows to estimate rates by maximum likelihood via <code>--mlrate</code> option:</p><pre><code>iqtree -s example.phy -n 0 --mlrate 
</code></pre><p>This will print an output file <code>example.phy.mlrate</code> that looks like:</p><pre><code># Site-specific subtitution rates determined by maximum likelihood
# This file can be read in MS Excel or in R with command:
#   tab=read.table('example.phy.mlrate',header=TRUE)
# Columns are tab-separated with following meaning:
#   Site:   Alignment site ID
#   Rate:   Site rate estimated by maximum likelihood
Site    Rate
1       2.51550
2       12.89129
3       34.31350
4       2.44313
5       2.44313
6       4.41889
7       2.69577
8       9.27503
9       2.44313
10      0.00001
</code></pre></classify1>",Inferring site-specific rates,10.0,10.0,"IQ-TREE allows to infer site-specific evolutionary rates if a site-rate heterogeneity model such as Gamma or FreeRate is the best model. Here, IQ-TREE will estimate model parameters and then apply an empirical Bayesian approach to assign site-rates as the mean over rate categories, weighted by the posterior probability of the site falling into each category. This approach is provided in IQ-TREE because such empirical Bayesian approach was shown to be most accurate (Mayrose et al., 2004). An example run:"
"<classify1 id=""10""><h2 id=""where-to-go-from-here"">Where to go from here?</h2><div class=""hline""></div><p>See <a href=""http://www.iqtree.org/doc/Command-Reference"">Command Reference</a> for a complete list of all options available in IQ-TREE.</p><div class=""spacing""></div></classify1>",Where to go from here?,11.0,11.0,See Command Reference for a complete list of all options available in IQ-TREE.
"<classify1 id=""0""><h2 id=""input-data"">Input data</h2><div class=""hline""></div><p>IQ-TREE takes as input a <em>multiple sequence alignment</em> and will reconstruct an evolutionary tree that is best explained by the input data. If you have raw (unaligned) sequences, you need to first run an alignment program like <a href=""http://mafft.cbrc.jp/alignment/software/"">MAFFT</a> or <a href=""http://www.clustal.org/"">ClustalW</a> to align the sequences, before feeding them into IQ-TREE.</p><p>The input alignment can be in various common formats. For example the <a href=""http://evolution.genetics.washington.edu/phylip/doc/sequence.html"">PHYLIP format</a> which may look like:</p><pre><code>7 28
Frog       AAATTTGGTCCTGTGATTCAGCAGTGAT
Turtle     CTTCCACACCCCAGGACTCAGCAGTGAT
Bird       CTACCACACCCCAGGACTCAGCAGTAAT
Human      CTACCACACCCCAGGAAACAGCAGTGAT
Cow        CTACCACACCCCAGGAAACAGCAGTGAC
Whale      CTACCACGCCCCAGGACACAGCAGTGAT
Mouse      CTACCACACCCCAGGACTCAGCAGTGAT
</code></pre><p>This tiny alignment contains 7 DNA sequences from several animals with the sequence length of 28 nucleotides. IQ-TREE also supports other file formats such as FASTA, NEXUS, CLUSTALW. The FASTA file for the above example may look like this:</p><pre><code>&gt;Frog       
AAATTTGGTCCTGTGATTCAGCAGTGAT
&gt;Turtle     
CTTCCACACCCCAGGACTCAGCAGTGAT
&gt;Bird       
CTACCACACCCCAGGACTCAGCAGTAAT
&gt;Human      
CTACCACACCCCAGGAAACAGCAGTGAT
&gt;Cow        
CTACCACACCCCAGGAAACAGCAGTGAC
&gt;Whale      
CTACCACGCCCCAGGACACAGCAGTGAT
&gt;Mouse      
CTACCACACCCCAGGACTCAGCAGTGAT
</code></pre><blockquote class=""tip""><p><strong>TIP</strong>: From version 2 you can input a directory of alignment files. IQ-TREE 2 will load and concatenate all alignments within the directory, eliminating the need for users to manually perform this step.</p></blockquote></classify1>",Input data,12.0,12.0,"IQ-TREE takes as input a multiple sequence alignment and will reconstruct an evolutionary tree that is best explained by the input data. If you have raw (unaligned) sequences, you need to first run an alignment program like MAFFT or ClustalW to align the sequences, before feeding them into IQ-TREE."
"<classify1 id=""1""><h2 id=""first-running-example"">First running example</h2><div class=""hline""></div><p>From the download there is an example alignment called <code>example.phy</code> in PHYLIP format. This example contains parts of the mitochondrial DNA sequences of several animals (Source: <a href=""http://www.kuleuven.be/aidslab/phylogenybook/home.html"">Phylogenetic Handbook</a>).</p><p>You can now start to reconstruct a maximum-likelihood tree from this alignment by entering (assuming that you are now in the same folder with <code>example.phy</code>):</p><pre><code>iqtree -s example.phy
</code></pre><p><code>-s</code> is the option to specify the name of the alignment file that is always required by IQ-TREE to work. At the end of the run IQ-TREE will write several output files including:</p><ul><li><code>example.phy.iqtree</code>: the main report file that is self-readable. You should look at this file to see the computational results. It also contains a textual representation of the final tree (see below).</li><li><code>example.phy.treefile</code>: the ML tree in NEWICK format, which can be visualized by any supported tree viewer programs like FigTree or iTOL.</li><li><code>example.phy.log</code>: log file of the entire run (also printed on the screen). To report bugs, please send this log file and the original alignment file to the authors.</li></ul><p>For this example data the resulting maximum-likelihood tree may look like this (extracted from <code>.iqtree</code> file):</p><pre><code>NOTE: Tree is UNROOTED although outgroup taxon 'LngfishAu' is drawn at root

+--------------LngfishAu
|
|        +--------------LngfishSA
+--------|
|        +--------------LngfishAf
|
|      +-------------------Frog
+------|
       |               +-----------------Turtle
       |         +-----|
       |         |     |      +-----------------------Sphenodon
       |         |     |   +--|
       |         |     |   |  +--------------------------Lizard
       |         |     +---|
       |         |         |      +---------------------Crocodile
       |         |         +------|
       |         |                +------------------Bird
       +---------|
                 |                  +----------------Human
                 |               +--|
                 |               |  |  +--------Seal
                 |               |  +--|
                 |               |     |   +-------Cow
                 |               |     +---|
                 |               |         +---------Whale
                 |          +----|
                 |          |    |         +------Mouse
                 |          |    +---------|
                 |          |              +--------Rat
                 +----------|
                            |   +----------------Platypus
                            +---|
                                +-------------Opossum
</code></pre><p>This makes sense as the mammals (<code>Human</code> to <code>Opossum</code>) form a clade, whereas the reptiles (<code>Turtle</code> to <code>Crocodile</code>) and <code>Bird</code> form a separate sister clade. Here the tree is drawn at the <em>outgroup</em> Lungfish which is more accient than other species in this example. However, please note that IQ-TREE always produces an <strong>unrooted tree</strong> as it knows nothing about this biological background; IQ-TREE simply draws the tree this way as <code>LngfishAu</code> is the first sequence occuring in the alignment.</p><p>During the example run above, IQ-TREE periodically wrote to disk a checkpoint file <code>example.phy.ckp.gz</code> (gzip-compressed to save space). This checkpoint file is used to resume an interrupted run, which is handy if you have a very large data sets or time limit on a cluster system. If the run did not finish, invoking IQ-TREE again with the very same command line will recover the analysis from the last stopped point, thus saving all computation time done before.</p><p>If the run successfully completed, running again will issue an error message:</p><pre><code>ERROR: Checkpoint (example.phy.ckp.gz) indicates that a previous run successfully finished
Use `-redo` option if you really want to redo the analysis and overwrite all output files.
</code></pre><p>This prevents lost of data if you accidentally re-run IQ-TREE. However, if you really want to re-run the analysis and overwrite all previous output files, use <code>-redo</code> option:</p><pre><code>iqtree -s example.phy -redo
</code></pre><p>Finally, the default prefix of all output files is the alignment file name. You can<br/> change the prefix with:</p><pre><code>iqtree -s example.phy --prefix myprefix
# for version 1.x change --prefix to -pre
</code></pre><p>This prevents output files being overwritten when you perform multiple analyses on the same alignment within the same folder.</p></classify1>",First running example,13.0,13.0,From the download there is an example alignment called example.phy in PHYLIP format. This example contains parts of the mitochondrial DNA sequences of several animals (Source: Phylogenetic Handbook).
"<classify1 id=""2""><h2 id=""choosing-the-right-substitution-model"">Choosing the right substitution model</h2><div class=""hline""></div><p>NOTE: If you use model selection please cite the following paper:</p><blockquote><p><strong>S. Kalyaanamoorthy, B.Q. Minh, T.K.F. Wong, A. von Haeseler, and L.S. Jermiin</strong> (2017) ModelFinder: fast model selection for accurate phylogenetic estimates. <em>Nat. Methods</em>, 14:587–589. DOI: <a href=""https://doi.org/10.1038/nmeth.4285"">10.1038/nmeth.4285</a></p></blockquote><p>IQ-TREE supports a wide range of <a href=""http://www.iqtree.org/doc/Substitution-Models"">substitution models</a> for DNA, protein, codon, binary and morphological alignments. If you do not know which model is appropriate for your data, you can use ModelFinder to determine the best-fit model:</p><pre><code>iqtree -s example.phy -m MFP
# change -m MFP to -m TEST to resemble jModelTest/ProtTest
</code></pre><p><code>-m</code> is the option to specify the model name to use during the analysis. The special <code>MFP</code> key word stands for <em>ModelFinder Plus</em>, which tells IQ-TREE to perform ModelFinder and the remaining analysis using the selected model. ModelFinder computes the log-likelihoods of an initial parsimony tree for many different models and the <em>Akaike information criterion</em> (AIC), <em>corrected Akaike information criterion</em> (AICc), and the <em>Bayesian information criterion</em> (BIC). Then ModelFinder chooses the model that minimizes the BIC score (you can also change to AIC or AICc by adding the option <code>-AIC</code> or <code>-AICc</code>, respectively).</p><blockquote class=""tip""><p><strong>TIP</strong>: Starting with version 1.5.4, <code>-m MFP</code> is the default behavior. Thus, this run is equivalent to <code>iqtree -s example.phy</code>.</p></blockquote><p>Here, IQ-TREE will write an additional file:</p><ul><li><code>example.phy.model</code>: log-likelihoods for all models tested. It serves as a checkpoint file to recover an interrupted model selection.</li></ul><p>If you now look at <code>example.phy.iqtree</code> you will see that IQ-TREE selected <code>TIM2+I+G4</code> as the best-fit model for this example data. Thus, for additional analyses you do not have to perform the model test again and can use the selected model:</p><pre><code>iqtree -s example.phy -m TIM2+I+G
</code></pre><p>Sometimes you only want to find the best-fit model without doing tree reconstruction, then run:</p><pre><code>iqtree -s example.phy -m MF
# change -m MF to -m TESTONLY to resemble jModelTest/ProtTest
</code></pre><p>By default, the maximum number of categories is limitted to 10 due to computational reasons. If your sequence alignment is long enough, then you can increase this upper limit with the <code>cmax</code> option:</p><pre><code>iqtree -s example.phy -m MF -cmax 15
</code></pre><p>will test <code>+R2</code> to <code>+R15</code> instead of at most <code>+R10</code>.</p><p>To reduce computational burden, one can use the option <code>-mset</code> to restrict the testing procedure to a subset of base models instead of testing the entire set of all available models. For example, <code>-mset WAG,LG</code> will test only models like <code>WAG+...</code> or <code>LG+...</code>. Another useful option in this respect is <code>-msub</code> for AA data sets. With <code>-msub nuclear</code> only general AA models are included, whereas with <code>-msub viral</code> only AA models for viruses are included.</p><p>If you have enough computational resource, you can perform a thorough and more accurate analysis that invokes a full tree search for each model considered via the <code>-mtree</code> option:</p><pre><code>iqtree -s example.phy -m MF -mtree
</code></pre></classify1>",Choosing the right substitution model,14.0,14.0,NOTE: If you use model selection please cite the following paper:
"<classify1 id=""3""><h2 id=""using-codon-models"">Using codon models</h2><div class=""hline""></div><p>IQ-TREE supports a number of <a href=""http://www.iqtree.org/doc/Substitution-Models#codon-models"">codon models</a>. You need to input a protein-coding DNA alignment and specify codon data by option <code>-st CODON</code> (Otherwise, IQ-TREE applies DNA model because it detects that your alignment has DNA sequences):</p><pre><code>iqtree -s coding_gene.phy -st CODON 
</code></pre><p>If your alignment length is not divisible by 3, IQ-TREE will stop with an error message. IQ-TREE will group sites 1,2,3 into codon site 1; sites 4,5,6 to codon site 2; etc. Moreover, any codon, which has at least one gap/unknown/ambiguous nucleotide, will be treated as unknown codon character.</p><p>Note that the above command assumes the standard genetic code. If your sequences follow ‘The Invertebrate Mitochondrial Code’ (see <a href=""http://www.iqtree.org/doc/Substitution-Models#codon-models"">the full list of supported genetic code here</a>), then run:</p><pre><code>iqtree -s coding_gene.phy -st CODON5 
</code></pre></classify1>",Using codon models,15.0,15.0,"IQ-TREE supports a number of codon models. You need to input a protein-coding DNA alignment and specify codon data by option -st CODON (Otherwise, IQ-TREE applies DNA model because it detects that your alignment has DNA sequences):"
"<classify1 id=""4""><h2 id=""binary-morphological-and-snp-data"">Binary, morphological and SNP data</h2><div class=""hline""></div><p>Binary alignments contain sequences with characters 0 and 1, which can be in any common formats supported by IQ-TREE, for example, in PHYLIP format:</p><pre><code>4 6
S1   010101
S2   110011
S3   0--100
S4   10--10
</code></pre><p>Morphological alignments have an extended characeter alphabet of 0-9 and A-Z (for states 10-31). For example (PHYLIP format):</p><pre><code>4 10
S1   0123401234
S2   03---20432
S3   3202-04--0
S4   4230120340
</code></pre><p>IQ-TREE will automatically determine the sequence type and the alphabet size. To run IQ-TREE on such alignments:</p><pre><code>iqtree -s morphology.phy
</code></pre><p>or</p><pre><code>iqtree -s morphology.phy -st MORPH
</code></pre><p>IQ-TREE implements to two morphological ML models: <a href=""http://www.iqtree.org/doc/Substitution-Models#binary-and-morphological-models"">MK and ORDERED</a>. Morphological data typically do not have constant (uninformative) sites. In such cases, you should apply <a href=""http://www.iqtree.org/doc/Substitution-Models#ascertainment-bias-correction"">ascertainment bias correction</a> model by e.g.:</p><pre><code>iqtree -s morphology.phy -st MORPH -m MK+ASC
</code></pre><p>You can again select the best-fit binary/morphological model:</p><pre><code>iqtree -s morphology.phy -st MORPH
</code></pre><p>For SNP data (DNA) that typically do not contain constant sites, you can explicitly tell the model to include ascertainment bias correction:</p><pre><code>iqtree -s SNP_data.phy -m GTR+ASC
</code></pre><p>You can explicitly tell model testing to only include <code>+ASC</code> model with:</p><pre><code>iqtree -s SNP_data.phy -m MFP+ASC
</code></pre></classify1>","Binary, morphological and SNP data",16.0,16.0,"Binary alignments contain sequences with characters 0 and 1, which can be in any common formats supported by IQ-TREE, for example, in PHYLIP format:"
"<classify1 id=""5""><h2 id=""assessing-branch-supports-with-ultrafast-bootstrap-approximation"">Assessing branch supports with ultrafast bootstrap approximation</h2><div class=""hline""></div><p>To overcome the computational burden required by the nonparametric bootstrap, IQ-TREE introduces an ultrafast bootstrap approximation (UFBoot) (<a href=""https://doi.org/10.1093/molbev/mst024"">Minh et al., 2013</a>; <a href=""https://doi.org/10.1093/molbev/msx281"">Hoang et al., 2018</a>) that is orders of magnitude faster than the standard procedure and provides relatively unbiased branch support values. Citation for UFBoot:</p><blockquote><p><strong>D.T. Hoang, O. Chernomor, A. von Haeseler, B.Q. Minh, and L.S. Vinh</strong> (2018) UFBoot2: Improving the ultrafast bootstrap approximation. <em>Mol. Biol. Evol.</em>, 35:518–522. <a href=""https://doi.org/10.1093/molbev/msx281"">https://doi.org/10.1093/molbev/msx281</a></p></blockquote><p>To run UFBoot:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -B 1000
# for version 1.x change -B to -bb
</code></pre><p><code>-B</code> specifies the number of bootstrap replicates where 1000 is the minimum number recommended. The section <code>MAXIMUM LIKELIHOOD TREE</code> in <code>example.phy.iqtree</code> shows a textual representation of the maximum likelihood tree with branch support values in percentage. The NEWICK format of the tree is printed to the file <code>example.phy.treefile</code>. In addition, IQ-TREE writes the following files:</p><ul><li><code>example.phy.contree</code>: the consensus tree with assigned branch supports where branch lengths are optimized on the original alignment.</li><li><code>example.phy.splits.nex</code>: support values in percentage for all splits (bipartitions), computed as the occurence frequencies in the bootstrap trees. This file can be viewed with the program <a href=""http://www.splitstree.org/"">SplitsTree</a> to explore the conflicting signals in the data. So it is more informative than consensus tree, e.g. you can see how highly supported the second best conflicting split is, which had no chance to enter the consensus tree.</li><li><code>example.phy.splits</code> (if using <code>-wsplits</code> option): This file contains the same information as <code>example.phy.splits.nex</code> but in star-dot format.</li></ul><blockquote><p><strong>NOTE</strong>: UFBoot support values have a different interpretation to the standard bootstrap. Refer to <a href=""http://www.iqtree.org/doc/Frequently-Asked-Questions#how-do-i-interpret-ultrafast-bootstrap-ufboot-support-values"">FAQ: UFBoot support values interpretation</a> for more information.</p></blockquote></classify1>",Assessing branch supports with ultrafast bootstrap approximation,17.0,17.0,"To overcome the computational burden required by the nonparametric bootstrap, IQ-TREE introduces an ultrafast bootstrap approximation (UFBoot) (Minh et al., 2013; Hoang et al., 2018) that is orders of magnitude faster than the standard procedure and provides relatively unbiased branch support values. Citation for UFBoot:"
"<classify1 id=""6""><h2 id=""reducing-impact-of-severe-model-violations-with-ufboot"">Reducing impact of severe model violations with UFBoot</h2><div class=""hline""></div><p>Starting with IQ-TREE version 1.6 we provide a new option <code>-bnni</code> to reduce the risk of overestimating branch supports with UFBoot due to severe model violations. With this option UFBoot will further optimize each bootstrap tree using a hill-climbing nearest neighbor interchange (NNI) search based directly on the corresponding bootstrap alignment.</p><p>Thus, if severe model violations are present in the data set at hand, users are advised to append <code>-bnni</code> to the regular UFBoot command:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -B 1000 -bnni
# for version 1.x change -B to -bb
</code></pre></classify1>",Reducing impact of severe model violations with UFBoot,18.0,18.0,Starting with IQ-TREE version 1.6 we provide a new option -bnni to reduce the risk of overestimating branch supports with UFBoot due to severe model violations. With this option UFBoot will further optimize each bootstrap tree using a hill-climbing nearest neighbor interchange (NNI) search based directly on the corresponding bootstrap alignment.
"<classify1 id=""7""><h2 id=""assessing-branch-supports-with--standard-nonparametric-bootstrap"">Assessing branch supports with standard nonparametric bootstrap</h2><div class=""hline""></div><p>The standard nonparametric bootstrap is invoked by the <code>-b</code> option:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -b 100
</code></pre><p><code>-b</code> specifies the number of bootstrap replicates where 100 is the minimum recommended number. The output files are similar to those produced by the UFBoot procedure.</p></classify1>",Assessing branch supports with standard nonparametric bootstrap,19.0,19.0,The standard nonparametric bootstrap is invoked by the -b option:
"<classify1 id=""8""><h2 id=""assessing-branch-supports-with-single-branch-tests"">Assessing branch supports with single branch tests</h2><div class=""hline""></div><p>IQ-TREE provides an implementation of the SH-like approximate likelihood ratio test (<a href=""https://doi.org/10.1093/sysbio/syq010"">Guindon et al., 2010</a>). To perform this test, run:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -alrt 1000
</code></pre><p><code>-alrt</code> specifies the number of bootstrap replicates for SH-aLRT where 1000 is the minimum number recommended.</p><p>IQ-TREE also supports other tests such as the aBayes test (<a href=""https://doi.org/10.1093/sysbio/syr041"">Anisimova et al., 2011</a>) and the local bootstrap test (<a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.476.8552"">Adachi and Hasegawa, 1996b</a>). See <a href=""http://www.iqtree.org/doc/Command-Reference#single-branch-tests"">single branch tests</a> for more details.</p><p>You can also perform both SH-aLRT and the ultrafast bootstrap within one single run:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -alrt 1000 -B 1000
# for version 1.x change -B to -bb
</code></pre><p>The branches of the resulting <code>.treefile</code> will be assigned with both SH-aLRT and UFBoot support values, which are readable by any tree viewer program like FigTree, Dendroscope or ETE. You can also look at the textual tree figure in <code>.iqtree</code> file:</p><pre><code>NOTE: Tree is UNROOTED although outgroup taxon 'LngfishAu' is drawn at root
Numbers in parentheses are SH-aLRT support (%) / ultrafast bootstrap support (%)

+-------------LngfishAu
|
|       +--------------LngfishSA
+-------| (100/100)
|       +------------LngfishAf
|
|      +--------------------Frog
+------| (99.8/100)
       |                     +-----------------Turtle
       |                  +--| (85/72)
       |                  |  |    +------------------------Crocodile
       |                  |  +----| (96.5/97)
       |                  |       +------------------Bird
       |               +--| (39/51)
       |               |  +---------------------------Sphenodon
       |         +-----| (98.2/99)
       |         |     +-------------------------------Lizard
       +---------| (100/100)
                 |                   +--------------Human
                 |                +--| (92.3/93)
                 |                |  |  +------Seal
                 |                |  +--| (68.3/75)
                 |                |     |  +-----Cow
                 |                |     +--| (99.7/100)
                 |                |        +-------Whale
                 |           +----| (99.1/100)
                 |           |    |         +---Mouse
                 |           |    +---------| (100/100)
                 |           |              +------Rat
                 +-----------| (100/100)
                             |  +--------------Platypus
                             +--| (93/98)
                                +-----------Opossum
</code></pre><p>From this figure, the branching patterns within reptiles are poorly supported (e.g. <code>Sphenodon</code> with SH-aLRT: 39%, UFBoot: 51% and <code>Turtle</code> with SH-aLRT: 85%, UFBoot: 72%) as well as the phylogenetic position of <code>Seal</code> within mammals (SH-aLRT: 68.3%, UFBoot: 75%). Other branches appear to be well supported.</p></classify1>",Assessing branch supports with single branch tests,20.0,20.0,"IQ-TREE provides an implementation of the SH-like approximate likelihood ratio test (Guindon et al., 2010). To perform this test, run:"
"<classify1 id=""9""><h2 id=""utilizing-multi-core-cpus"">Utilizing multi-core CPUs</h2><div class=""hline""></div><p>IQ-TREE can utilize multiple CPU cores to speed up the analysis. A complement option <code>-T</code> (or <code>-nt</code> for version 1.x) allows specifying the number of CPU cores to use. For example:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -T 2
# for version 1.x change -T to -nt
</code></pre><p>Here, IQ-TREE will use 2 CPU cores to perform the analysis.</p><p>Note that the parallel efficiency is only good for long alignments. A good practice is to use <code>-T AUTO</code> to determine the best number of cores:</p><pre><code>iqtree -s example.phy -m TIM2+I+G -T AUTO
# for version 1.x change -T to -nt
</code></pre><p>Then while running IQ-TREE may print something like this on to the screen:</p><pre><code>Measuring multi-threading efficiency up to 8 CPU cores
Threads: 1 / Time: 8.001 sec / Speedup: 1.000 / Efficiency: 100% / LogL: -22217
Threads: 2 / Time: 4.346 sec / Speedup: 1.841 / Efficiency: 92% / LogL: -22217
Threads: 3 / Time: 3.381 sec / Speedup: 2.367 / Efficiency: 79% / LogL: -22217
Threads: 4 / Time: 4.385 sec / Speedup: 1.825 / Efficiency: 46% / LogL: -22217
BEST NUMBER OF THREADS: 3
</code></pre><p>Therefore, I would only use 3 cores for this example data. For later analysis with your same data set, you can stick to the determined number.</p><p>Depending on the compute system it might be required to set an upper limit of CPU cores that can automatically be assigned. Use the <code>-ntmax</code> option to do so. For instance</p><pre><code>iqtree -s example.phy -m TIM2+I+G -T AUTO -ntmax 8
# for version 1.x change -T to -nt
</code></pre><p>does the same as above, but only allows to use up to 8 CPU cores. By default all cores of the current machine would be used as maximum.</p></classify1>",Utilizing multi-core CPUs,21.0,21.0,IQ-TREE can utilize multiple CPU cores to speed up the analysis. A complement option -T (or -nt for version 1.x) allows specifying the number of CPU cores to use. For example:
"<classify1 id=""10""><h2 id=""where-to-go-from-here"">Where to go from here?</h2><div class=""hline""></div><p>Once confident enough you can go on with a <strong><a href=""http://www.iqtree.org/doc/Advanced-Tutorial"">more advanced tutorial</a></strong>, which covers topics like phylogenomic (multi-gene) analyses using partition models or mixture models.</p><div class=""spacing""></div></classify1>",Where to go from here?,22.0,22.0,"Once confident enough you can go on with a more advanced tutorial, which covers topics like phylogenomic (multi-gene) analyses using partition models or mixture models."
"<classify1 id=""0""><h2 id=""general-requirements"">General requirements</h2><div class=""hline""></div><ul><li><p>A C++ compiler such as GCC (version &gt;= 4.8), Clang, MS Visual Studio and Intel C++ compiler.</p></li><li><p><a href=""http://www.cmake.org/"">CMake</a> version &gt;= 2.8.10.</p></li><li><p><a href=""https://www.boost.org/"">Boost library</a> for IQ-TREE version 2. Boost library is typically available under Linux. Under MacOS you use <a href=""https://brew.sh/"">Homebrew</a> and run <code>brew install boost</code> to install the Boost library. By default IQ-TREE will detect the path to the installed Boost library.</p></li><li><p><a href=""https://eigen.tuxfamily.org/"">Eigen3 library</a> (for IQ-TREE version &gt;= 1.6). Under MacOS you use <a href=""https://brew.sh/"">Homebrew</a> and run <code>brew install eigen</code> to install the Boost library. By default IQ-TREE will detect the path to the installed Eigen3 library. If this failed, you have to manually specify <code>-DEIGEN3_INCLUDE_DIR=&lt;installed_eigen3_dir&gt;</code> to the <code>cmake</code> command (see below).</p></li><li><p>OpenMP library, which is used to compile the multicore version. This should typically be the case with <code>gcc</code> under Linux. Under MacOS you use <a href=""https://brew.sh/"">Homebrew</a> and run <code>brew install libomp</code> to install the OpenMP library.</p></li><li><p>(<em>Optional</em>) Install <a href=""https://git-scm.com/"">git</a> if you want to clone source code from <a href=""https://github.com/Cibiv/IQ-TREE"">IQ-TREE GitHub repository</a>.</p></li></ul></classify1>",General requirements,23.0,23.0,"A C++ compiler such as GCC (version >= 4.8), Clang, MS Visual Studio and Intel C++ compiler.CMake version >= 2.8.10.Boost library for IQ-TREE version 2. Boost library is typically available under Linux. Under MacOS you use Homebrew and run brew install boost to install the Boost library. By default IQ-TREE will detect the path to the installed Boost library.Eigen3 library (for IQ-TREE version >= 1.6). Under MacOS you use Homebrew and run brew install eigen to install the Boost library. By default IQ-TREE will detect the path to the installed Eigen3 library. If this failed, you have to manually specify -DEIGEN3_INCLUDE_DIR=<installed_eigen3_dir> to the cmake command (see below).OpenMP library, which is used to compile the multicore version. This should typically be the case with gcc under Linux. Under MacOS you use Homebrew and run brew install libomp to install the OpenMP library.(Optional) Install git if you want to clone source code from IQ-TREE GitHub repository."
"<classify1 id=""1""><h2 id=""downloading-source-code"">Downloading source code</h2><div class=""hline""></div><p>Choose the source code (<code>zip</code> or <code>tar.gz</code>) of the IQ-TREE release you want to use from:</p><p><a href=""https://github.com/iqtree/iqtree2/releases"">https://github.com/iqtree/iqtree2/releases</a></p><p>For IQ-TREE version 1 please use:</p><p><a href=""https://github.com/Cibiv/IQ-TREE/releases/"">https://github.com/Cibiv/IQ-TREE/releases/</a></p><p>Alternatively, if you have <code>git</code> installed, you can also clone the source code from GitHub with:</p><pre><code>git clone https://github.com/iqtree/iqtree2.git
</code></pre><p>For IQ-TREE version 1 please clone:</p><pre><code>git clone https://github.com/Cibiv/IQ-TREE.git
</code></pre><p>Please find below separate compilation guide fors <a href=""http://www.iqtree.org/doc/Compilation-Guide#compiling-under-linux"">Linux</a>, <a href=""http://www.iqtree.org/doc/Compilation-Guide#compiling-under-mac-os-x"">Mac OS X</a>, and <a href=""http://www.iqtree.org/doc/Compilation-Guide#compiling-under-windows"">Windows</a> as well as for <a href=""http://www.iqtree.org/doc/Compilation-Guide#compiling-32-bit-version"">32-bit version</a> or for <a href=""http://www.iqtree.org/doc/Compilation-Guide#compiling-mpi-version"">MPI version</a>.</p></classify1>",Downloading source code,24.0,24.0,Choose the source code (zip or tar.gz) of the IQ-TREE release you want to use from:
"<classify1 id=""2""><h2 id=""compiling-under-linux"">Compiling under Linux</h2><div class=""hline""></div><blockquote class=""tip""><p><strong>TIP</strong>: Ready made IQ-TREE packages are provided for <a href=""https://packages.debian.org/unstable/science/iqtree"">Debian</a> and <a href=""https://aur.archlinux.org/packages/iqtree-latest/"">Arch Linux (AUR)</a>.</p></blockquote><ol><li>Open a Terminal.</li><li><p>Change to the source code folder:</p><pre><code> cd PATH_TO_EXTRACTED_SOURCE_CODE
</code></pre></li><li><p>Create a subfolder, say, <code>build</code> and go into this subfolder:</p><pre><code> mkdir build
 cd build
</code></pre></li><li><p>Configure source code with CMake:</p><pre><code> cmake ..
</code></pre><p>If <code>cmake</code> failed with message about <code>Eigen3 not found</code>, then install Eigen3 library and run <code>cmake</code> again. If this still failed, you have to manually specify the downloaded directory of Eigen3 with:</p><pre><code> cmake -DEIGEN3_INCLUDE_DIR=&lt;eigen3_dir&gt; ..
</code></pre></li><li><p>Compile source code with <code>make</code>:</p><pre><code> make -j
</code></pre><p><code>j</code> option tells it to use all CPU cores to speed up the compilation. Without this option, <code>make</code> uses only one core, which might be slow.</p></li></ol><p>This creates an executable <code>iqtree2</code> (<code>iqtree</code> for version 1). It can be copied to your system search path so that IQ-TREE can be called from the Terminal simply with the command line <code>iqtree2</code>.</p><blockquote class=""tip""><p><strong>TIP</strong>: The above guide typically compiles IQ-TREE with <code>gcc</code>. If you have Clang installed and want to compile with Clang, the compilation will be similar to Mac OS X like below.</p></blockquote></classify1>",Compiling under Linux,25.0,25.0,TIP: Ready made IQ-TREE packages are provided for Debian and Arch Linux (AUR).
"<classify1 id=""3""><h2 id=""compiling-under-mac-os-x"">Compiling under Mac OS X</h2><div class=""hline""></div><blockquote class=""tip""><p><strong>TIP</strong>: A ready made IQ-TREE package is provided by * <a href=""https://github.com/brewsci/homebrew-science/blob/master/Formula/iqtree.rb"">Homebrew</a> by simply running <code>brew install homebrew/science/iqtree2</code>.</p></blockquote><ul><li><p>Make sure that Clang compiler is installed, which is typically the case if you installed Xcode and the associated command line tools.</p></li><li><p>If you installed cmake with Homebrew</p></li><li><p>Find the path to the CMake executable, which is typically <code>/Applications/CMake.app/Contents/bin/cmake</code>. For later convenience, please create a symbolic link <code>cmake</code> to this cmake executable, so that cmake can be invoked from the Terminal by simply entering <code>cmake</code>.</p></li></ul><p>The steps to compile IQ-TREE are similar to Linux (see above), except that you need to specify <code>clang</code> as compiler when configuring source code with CMake (step 4):</p><pre><code>cmake -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ ..
</code></pre><p>(please change <code>cmake</code> to absolute path like <code>/Applications/CMake.app/Contents/bin/cmake</code>).</p><p>To compile the multicore version, the default installed Clang unfortunately does not support OpenMP (which might change in the near future). However, the latest Clang 3.7 supports OpenMP, which can be downloaded from <a href=""http://clang.llvm.org/"">http://clang.llvm.org</a>. After that you can run CMake with:</p><pre><code>cmake -DIQTREE_FLAGS=omp -DCMAKE_C_COMPILER=clang-3.7 -DCMAKE_CXX_COMPILER=clang++-3.7 ..
</code></pre><p>(assuming that <code>clang-3.7</code> and <code>clang++-3.7</code> points to the installed Clang 3.7).</p></classify1>",Compiling under Mac OS X,26.0,26.0,TIP: A ready made IQ-TREE package is provided by * Homebrew by simply running brew install homebrew/science/iqtree2.
"<classify1 id=""4""><h2 id=""compiling-under-windows"">Compiling under Windows</h2><div class=""hline""></div><ul><li><p>Please first install TDM-GCC (a GCC version for Windows) from <a href=""http://tdm-gcc.tdragon.net/"">http://tdm-gcc.tdragon.net</a>.</p></li><li><p>Then install Clang for Windows from <a href=""http://clang.llvm.org/"">http://clang.llvm.org</a>.</p></li></ul><blockquote><p><strong>WARNING</strong>: Although IQ-TREE can also be built with TDM-GCC, the executable does not run properly due to stack alignment issue and the <code>libgomp</code> library causes downgraded performance for the OpenMP version. Thus, it is recommended to compile IQ-TREE with Clang.</p></blockquote><ol><li>Open Command Prompt.</li><li><p>Change to the source code folder:</p><pre><code> cd PATH_TO_EXTRACTED_SOURCE_CODE
</code></pre><p>Please note that Windows uses back-slash (<code>\</code>) instead of slash (<code>/</code>) as path name separator.</p></li><li><p>Create a subfolder, say, <code>build</code> and go into this subfolder:</p><pre><code> mkdir build
 cd build
</code></pre></li><li><p>Configure source code with CMake:</p><pre><code> cmake -G ""MinGW Makefiles"" -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_FLAGS=--target=x86_64-pc-windows-gnu -DCMAKE_CXX_FLAGS=--target=x86_64-pc-windows-gnu -DCMAKE_MAKE_PROGRAM=mingw32-make ..
</code></pre><p>To build the multicore version please add <code>-DIQTREE_FLAGS=omp</code> to the cmake command. Note that the make program shipped with TDM-GCC is called <code>mingw32-make</code>, thus needed to specify like above. You can also copy <code>mingw32-make</code> to <code>make</code> to simplify this step.</p></li><li><p>Compile source code with:</p><pre><code> mingw32-make
</code></pre><p>or</p><pre><code> mingw32-make -j4
</code></pre><p>to use 4 cores for compilation instead of only 1.</p></li></ol></classify1>",Compiling under Windows,27.0,27.0,Please first install TDM-GCC (a GCC version for Windows) from http://tdm-gcc.tdragon.net.Then install Clang for Windows from http://clang.llvm.org.
"<classify1 id=""5""><h2 id=""compiling-32-bit-version"">Compiling 32-bit version</h2><div class=""hline""></div><blockquote><p><strong>NOTE</strong>: Typically a 64-bit IQ-TREE version is built and recommended! The 32-bit version has several restriction like maximal RAM usage of 2GB and no AVX support, thus not suitable to analyze large data sets.</p></blockquote><p>To compile the 32-bit version instead, simply add <code>m32</code> into <code>IQTREE_FLAGS</code> of the cmake command:</p><pre><code>cmake -DIQTREE_FLAGS=m32 .. 
</code></pre><p>To build the 32-bit multicore version, run:</p><pre><code>cmake -DIQTREE_FLAGS=omp-m32 ..
</code></pre><p>For Windows you need to change Clang target with:</p><pre><code>cmake -G ""MinGW Makefiles"" -DCMAKE_C_FLAGS=--target=i686-pc-windows-gnu -DCMAKE_CXX_FLAGS=--target=i686-pc-windows-gnu -DCMAKE_MAKE_PROGRAM=mingw32-make ..
</code></pre></classify1>",Compiling 32-bit version,28.0,28.0,"NOTE: Typically a 64-bit IQ-TREE version is built and recommended! The 32-bit version has several restriction like maximal RAM usage of 2GB and no AVX support, thus not suitable to analyze large data sets."
"<classify1 id=""6""><h2 id=""compiling-mpi-version"">Compiling MPI version</h2><div class=""hline""></div><p><strong>Requirements</strong>:</p><ul><li>Download source code of IQ-TREE version 1.5.1 or later.</li><li><p>Install an MPI library (e.g., <a href=""http://open-mpi.org/"">OpenMPI</a>) if not available in your system. For Mac OS X, the easiest is to install <a href=""http://brew.sh/"">Homebrew package manager</a>, and then install OpenMPI library from the command line with:</p><pre><code>  brew install openmpi
</code></pre></li></ul><p>Then simply run <code>CMake</code> and <code>make</code> by:</p><pre><code>cmake -DIQTREE_FLAGS=mpi ..
make -j4
</code></pre><p>IQ-TREE will automatically detect and setup the MPI paths and library. Alternatively, you can also use the MPI C/C++ compiler wrappers (typically named <code>mpicc</code> and <code>mpicxx</code>), for example:</p><pre><code>cmake -DCMAKE_C_COMPILER=mpicc -DCMAKE_CXX_COMPILER=mpicxx ..
make -j4
</code></pre><p>The executable is named <code>iqtree-mpi</code>. One can then run <code>mpirun</code> to start the MPI version with e.g. 2 processes:</p><pre><code>mpirun -np 2 iqtree-mpi -s alignment ...
</code></pre><p>If you want to compile the hybrid MPI/OpenMP version, simply run:</p><pre><code>cmake -DIQTREE_FLAGS=omp-mpi ..
make -j4
</code></pre><p>The resulting executable is then named <code>iqtree-mpi</code> (<code>iqtree-omp-mpi</code> for IQ-TREE versions &lt;= 1.5.X). This can be used to start an MPI run with e.g. 4 processes and 2 cores each (i.e., a total of 8 cores will be used):</p><pre><code># For IQ-TREE version &lt;= 1.5.X
mpirun -np 4 iqtree-omp-mpi -nt 2 -s alignment ...

# For IQ-TREE version &gt;= 1.6.0
mpirun -np 4 iqtree-mpi -nt 2 -s alignment ...
</code></pre><blockquote><p><strong>NOTE</strong>: Please be aware that <a href=""http://openmp.org/"">OpenMP</a> and <a href=""http://open-mpi.org/"">OpenMPI</a> are different! OpenMP is the standard to implement shared-memory multithreading program, that we use to provide the multicore IQ-TREE version. Whereas OpenMPI is a message passing interface (MPI) library for distributed memory parallel system, that is used to compile <code>iqtree-mpi</code>. Thus, <strong>one cannot run <code>iqtree</code> with <code>mpirun</code>!</strong></p></blockquote></classify1>",Compiling MPI version,29.0,29.0,Requirements:
"<classify1 id=""7""><h2 id=""compiling-xeon-phi-knights-landing-version"">Compiling Xeon Phi Knights Landing version</h2><div class=""hline""></div><p>Starting with version 1.6, IQ-TREE supports Xeon Phi Knights Landing (AVX-512 instruction set). To build this version the following requirements must be met:</p><ul><li>A C++ compiler, which supports AVX-512 instruction set: GCC 5.1, Clang 3.7, or Intel compiler 14.0.</li></ul><p>The compilation steps are the same except that you need to add <code>-DIQTREE_FLAGS=KNL</code> to the cmake command:</p><pre><code>cmake -DIQTREE_FLAGS=KNL ..
make -j4
</code></pre><p>The compiled <code>iqtree</code> binary will automatically choose the proper computational kernel for the running computer. Thus, it works as normal and will speed up on Knights Landing CPUs. Run <code>./iqtree</code> to make sure that the binary was compiled correctly:</p><pre><code>IQ-TREE multicore Xeon Phi KNL version 1.6.beta for Linux 64-bit built May  7 2017
</code></pre></classify1>",Compiling Xeon Phi Knights Landing version,30.0,30.0,"Starting with version 1.6, IQ-TREE supports Xeon Phi Knights Landing (AVX-512 instruction set). To build this version the following requirements must be met:"
"<classify1 id=""8""><h2 id=""about-precompiled-binaries"">About precompiled binaries</h2><div class=""hline""></div><p>To provide the pre-compiled IQ-TREE binaries at <a href=""http://www.iqtree.org/"">http://www.iqtree.org</a>, we used Clang 3.9.0 for Windows and Clang 4.0 for Linux and macOS. We recommend to use Clang instead of GCC as Clang-compiled binaries run about 5-10% faster than GCC-compiled ones.</p><p>Linux binaries were statically compiled with Ubuntu 16.4 using <a href=""https://libcxx.llvm.org/"">libc++ library</a>. The static-linked binaries will thus run on most Linux distributions. The CMake command is (assuming that clang-4 and clang++-4 point to the installed Clang):</p><pre><code># 64-bit version
cmake -DIQTREE_FLAGS=static-libcxx -DCMAKE_C_COMPILER=clang-4 -DCMAKE_CXX_COMPILER=clang++-4 &lt;source_dir&gt;

# 32-bit version
cmake -DIQTREE_FLAGS=static-m32 -DCMAKE_C_COMPILER=clang-4 -DCMAKE_CXX_COMPILER=clang++-4 &lt;source_dir&gt;
</code></pre><p>macOS binaries were compiled under macOS Sierra, but the binaries are backward compatible with Mac OS X 10.7 Lion:</p><pre><code>cmake -DCMAKE_C_COMPILER=clang-4 -DCMAKE_CXX_COMPILER=clang++-4 &lt;source_dir&gt;
</code></pre><p>Windows binaries were statically compiled under Windows 7 using Clang 3.9.0 in combination with <a href=""http://tdm-gcc.tdragon.net/"">TDM-GCC 5.1.0</a>, which provides the neccessary libraries for Clang.</p><pre><code># 64-bit version
cmake -G ""MinGW Makefiles"" -DIQTREE_FLAGS=static -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_FLAGS=--target=x86_64-pc-windows-gnu -DCMAKE_CXX_FLAGS=--target=x86_64-pc-windows-gnu -DCMAKE_MAKE_PROGRAM=mingw32-make ..

#32-bit version
cmake -G ""MinGW Makefiles"" -DIQTREE_FLAGS=static -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_FLAGS=--target=i686-pc-windows-gnu -DCMAKE_CXX_FLAGS=--target=i686-pc-windows-gnu -DCMAKE_MAKE_PROGRAM=mingw32-make ..
</code></pre></classify1>",About precompiled binaries,31.0,31.0,"To provide the pre-compiled IQ-TREE binaries at http://www.iqtree.org, we used Clang 3.9.0 for Windows and Clang 4.0 for Linux and macOS. We recommend to use Clang instead of GCC as Clang-compiled binaries run about 5-10% faster than GCC-compiled ones."
"<classify1 id=""9""><h2 id=""setup-an-xcode-project-in-macos"">Setup an Xcode project in MacOS</h2><div class=""hline""></div><p>Many developers in MacOS use Xcode to develop the code. To generate an XCode project for IQ-TREE, you need to run:</p><pre><code>mkdir build-xcode
cd build-xcode
cmake -G Xcode &lt;IQTREE_SOURCE_DIR&gt;
</code></pre><p>This will generate a a subfolder <code>build-xcode/iqtree.xcodeproj</code>, which you can open in Xcode now.</p><div class=""spacing""></div></classify1>",Setup an Xcode project in MacOS,32.0,32.0,"Many developers in MacOS use Xcode to develop the code. To generate an XCode project for IQ-TREE, you need to run:"
"<classify1 id=""0""><h2 id=""partition-models"">Partition models</h2><div class=""hline""></div><p>Partition models are intended for phylogenomic (e.g., multi-gene) alignments, which allow each partition to have its own substitution models and evolutionary rates. IQ-TREE supports three types of partition models:</p><ol><li><em>Edge-equal</em> partition model with equal branch lengths: All partitions share the same set of branch lengths.</li><li><em>Edge-proportional</em> partition model with proportional branch lengths: Like above but each partition has its own partition specific rate, that rescales all its branch lengths. This model accomodates different evolutionary rates between partitions (e.g. between 1st, 2nd, and 3rd codon positions).</li><li><em>Edge-unlinked</em> partition model: Each partition has its own set of branch lengths. This is the most parameter-rich partition model, that accounts for e.g., <em>heterotachy</em> (<a href=""http://mbe.oxfordjournals.org/content/19/1/1.full"">Lopez et al., 2002</a>).</li></ol><blockquote class=""tip""><p><strong>TIP</strong>: The edge-equal partition model is typically unrealistic as it does not account for different evolutionary speeds between partitions, whereas the edge-unlinked partition model can be overfitting if there are many short partitions. Therefore, the edge-proportional partition model is recommended for a typical analysis.</p></blockquote><h3 id=""partition-file-format"">Partition file format</h3><p>To apply partition models users must first prepare a partition file in RAxML-style or NEXUS format. The RAxML-style is defined by the RAxML software and may look like:</p><pre><code>DNA, part1 = 1-100
DNA, part2 = 101-384
</code></pre><p>This means two DNA partitions of an alignment, where one groups aligment sites <code>1-100</code> into <code>part1</code> and <code>101-384</code> into <code>part2</code>.</p><p>The NEXUS format is more complex but more powerful. For example, the above partition scheme may look like:</p><pre><code>#nexus
begin sets;
    charset part1 = 1-100;
    charset part2 = 101-384;
    charpartition mine = HKY+G:part1, GTR+I+G:part2;
end;
</code></pre><p>The first line contains the keyword <code>#nexus</code> to indicate a NEXUS file. It has a <code>sets</code> block, which contains two character sets (<code>charset</code> command) named <code>part1</code> and <code>part2</code>. Furthermore, with the <code>charpartition</code> command we set the model <code>HKY+G</code> for <code>part1</code> and <code>GTR+I+G</code> for <code>part2</code>. This is not possible with the RAxML-style format (i.e., one cannot specify <code>+G</code> rate model for one partition and <code>+I+G</code> rate model for the other partition).</p><blockquote class=""tip""><p><strong>TIP</strong>: IQ-TREE fully supports mixed rate heterogeneity types types between partitions (see above example).</p></blockquote><p>One can also specify non-consecutive sites of a partition, e.g. under RAxML-style format:</p><pre><code>DNA, part1 = 1-100, 250-384
DNA, part2 = 101-249\3, 102-249\3
DNA, part3 = 103-249\3
</code></pre><p>or under NEXUS format:</p><pre><code>#nexus
begin sets;
    charset part1 = 1-100 250-384;
    charset part2 = 101-249\3 102-249\3;
    charset part3 = 103-249\3;
end;
</code></pre><p>This means, <code>part2</code> contains sites 101, 102, 104, 105, 107, …, 246, 248, 249; whereas <code>part3</code> contains sites 103, 106, …, 247. This is useful to specify partitions corresponding to 1st, 2nd and 3rd codon positions.</p><p>Moreover, the NEXUS file allows each partition to come from a separate alignment file (not possible under RAxML-style format) with e.g.:</p><pre><code>#nexus
begin sets;
    charset part1 = aln1.phy: 1-100\3 201-300;
    charset part2 = aln1.phy: 101-200;
    charset part3 = aln2.phy: *;
    charpartition mine = HKY:part1, GTR+G:part2, WAG+I+G:part3;
end;
</code></pre><p>Here, <code>part1</code> and <code>part2</code> correspond to sub-alignments of <code>aln1.phy</code> file and <code>part3</code> is the entire alignment file <code>aln2.phy</code>. Note that <code>aln2.phy</code> is a protein alignment in this example.</p><blockquote class=""tip""><p><strong>TIP</strong>: IQ-TREE fully supports mixed data types between partitions.</p></blockquote><p>If you want to specify codon model for a partition, use the <code>CODON</code> keyword (otherwise, the partition may be detected as DNA):</p><pre><code>#nexus
begin sets;
    charset part1 = aln1.phy:CODON, 1-300;
    charset part2 = aln1.phy: 301-400;
    charset part3 = aln2.phy: *;
    charpartition mine = GY:part1, GTR+G:part2, WAG+I+G:part3;
end;
</code></pre><p>Note that this assumes <code>part1</code> has standard genetic code. If not, append <code>CODON</code> with <a href=""http://www.iqtree.org/doc/Substitution-Models#codon-models"">the right genetic code ID</a>.</p><h3 id=""partitioned-analysis"">Partitioned analysis</h3><p>Having prepared a partition file, one is ready to start a partitioned analysis with <code>-q</code> (edge-equal), <code>-spp</code> (edge-proportional) or <code>-sp</code> (edge-unlinked) option. See <a href=""http://www.iqtree.org/doc/Advanced-Tutorial#partitioned-analysis-for-multi-gene-alignments"">this tutorial</a> for more details.</p></classify1>",Partition models,33.0,33.0,"Partition models are intended for phylogenomic (e.g., multi-gene) alignments, which allow each partition to have its own substitution models and evolutionary rates. IQ-TREE supports three types of partition models:"
"<classify1 id=""1""><h2 id=""mixture-models"">Mixture models</h2><div class=""hline""></div><h3 id=""what-is-the-difference-between-partition-and-mixture-models"">What is the difference between partition and mixture models?</h3><p>Mixture models, like partition models, allow more than one substitution model along the sequences. However, while a partition model assigns each alignment site a given specific model, mixture models do not need this information. A mixture model will compute for each site its probability (or weight) of belonging to each of the mixture classes (also called categories or components). Since the site-to-class assignment is unknown, the site likelihood under mixture models is the weighted sum of site likelihoods per mixture class.</p><p>For example, the <a href=""http://www.iqtree.org/doc/Substitution-Models#rate-heterogeneity-across-sites"">discrete Gamma rate heterogeneity</a> is a simple mixture model type. It has several rate categories with equal weight. IQ-TREE also supports a number of <a href=""http://www.iqtree.org/doc/Substitution-Models#protein-mixture-models"">predefined protein mixture models</a> such as the profile mixture models <code>C10</code> to <code>C60</code> (The ML variants of Bayesian <code>CAT</code> models).</p><p>Here, we discuss several possibilities to define new mixture models in IQ-TREE.</p><h3 id=""defining-mixture-models"">Defining mixture models</h3><p>To start with, the following command:</p><pre><code>iqtree -s example.phy -m ""MIX{JC,HKY}""
</code></pre><p>specifies a mixture model (via the <code>MIX</code> keyword in the model string) with two components. The components (1) <code>JC</code> model, and (2) <code>HKY</code> model, are given in curly brackets and separated with a comma. IQ-TREE will then estimate the parameters of both mixture components as well as their weights: the proportion of sites belonging to each component.</p><blockquote><p><strong>NOTE</strong>: Do not forget the double-quotes around model string! They prevent interpretation of the curly brackets by the command line shell, i.e., <code>MIX{JC,HKY}</code> would otherwise be interpreted as <code>MIXJC MIXHKY</code>.</p></blockquote><p>Mixture models can be combined with rate heterogeneity, e.g.:</p><pre><code>iqtree -s example.phy -m ""MIX{JC,HKY}+G4""
</code></pre><p>Here, we specify two mixture components and four Gamma rate categories. Effectively, this means that there are eight mixture components. Each site has a probability belonging to either <code>JC</code> or <code>HKY</code> and to one of the four rate categories.</p><h3 id=""profile-mixture-models"">Profile mixture models</h3><p>Sometimes one only wants to model the changes in nucleotide or amino-acid frequencies along the sequences while keeping the substitution rate matrix the same. This can be specified in IQ-TREE via <code>FMIX{...}</code> model syntax. For convenience the mixture components can be defined in a NEXUS file like this (example corresponds to <a href=""http://www.iqtree.org/doc/Substitution-Models#protein-mixture-models"">the CF4 model</a> of (<a href=""https://doi.org/10.1186/1471-2148-8-331"">Wang et al., 2008</a>)):</p><pre><code>#nexus
begin models;
    frequency Fclass1 = 0.02549352 0.01296012 0.005545202 0.006005566 0.01002193 0.01112289 0.008811948 0.001796161 0.004312188 0.2108274 0.2730413 0.01335451 0.07862202 0.03859909 0.005058205 0.008209453 0.03210019 0.002668138 0.01379098 0.2376598;
    frequency Fclass2 = 0.09596966 0.008786096 0.02805857 0.01880183 0.005026264 0.006454635 0.01582725 0.7215719 0.003379354 0.002257725 0.003013483 0.01343441 0.001511657 0.002107865 0.006751404 0.04798539 0.01141559 0.000523736 0.002188483 0.004934972;
    frequency Fclass3 = 0.01726065 0.005467988 0.01092937 0.3627871 0.001046402 0.01984758 0.5149206 0.004145081 0.002563289 0.002955213 0.005286931 0.01558693 0.002693098 0.002075771 0.003006167 0.01263069 0.01082144 0.000253451 0.001144787 0.004573568;
    frequency Fclass4 = 0.1263139 0.09564027 0.07050061 0.03316681 0.02095119 0.05473468 0.02790523 0.009007538 0.03441334 0.005855319 0.008061884 0.1078084 0.009019514 0.05018693 0.07948 0.09447839 0.09258897 0.01390669 0.05367769 0.01230413;

    frequency CF4model = FMIX{empirical,Fclass1,Fclass2,Fclass3,Fclass4};
end;
</code></pre><blockquote><p><strong>NOTE</strong>: The amino-acid order in this file is: A R N D C Q E G H I L K M F P S T W Y V.</p></blockquote><p>Here, the NEXUS file contains a <code>models</code> block to define new models. More explicitly, we define four AA profiles <code>Fclass1</code> to <code>Fclass4</code>, each containing 20 AA frequencies. Then, the frequency mixture is defined with</p><pre><code>FMIX{empirical,Fclass1,Fclass2,Fclass3,Fclass4}
</code></pre><p>This means, we have five components: the first corresponds to empirical AA frequencies to be inferred from the data and the remaining four components are specified in this NEXUS file. Please save this to a file, say, <code>mymodels.nex</code>. One can now start the analysis with:</p><pre><code>iqtree -s some_protein.aln -mdef mymodels.nex -m JTT+CF4model+G
</code></pre><p>The <code>-mdef</code> option specifies the NEXUS file containing user-defined models. Here, the <code>JTT</code> matrix is applied for all alignment sites and one varies the AA profiles along the alignment. One can use the NEXUS syntax to define all other profile mixture models such as <code>C10</code> to <code>C60</code>.</p><h3 id=""nexus-model-file"">NEXUS model file</h3><p>In fact, IQ-TREE uses this NEXUS model file internally to define all <a href=""http://www.iqtree.org/doc/Substitution-Models#protein-mixture-models"">protein mixture models</a>. In addition to defining state frequencies, one can specify the entire model with rate matrix and state frequencies together. For example, the LG4M model (<a href=""https://doi.org/10.1093/molbev/mss112"">Le et al., 2012</a>) can be defined by:</p><pre><code>#nexus
begin models;
    model LG4M1 =
        0.269343
        0.254612 0.150988
        0.236821 0.031863 0.659648
        ....;
    ....
    model LG4M4 = ....;
    
    model LG4M = MIX{LG4M1,LG4M2,LG4M3,LG4M4}*G4;
end;
</code></pre><p>Here, we first define the four matrices <code>LG4M1</code>, <code>LG4M2</code>, <code>LG4M3</code> and <code>LG4M4</code> in PAML format (see <a href=""http://www.iqtree.org/doc/Substitution-Models#protein-models"">protein models</a>). Then <code>LG4M</code> is defined as mixture model with these four components <em>fused</em> with Gamma rate heterogeneity (via <code>*G4</code> syntax instead of <code>+G4</code>). This means that, in total, we have 4 mixture components instead of 16. The first component <code>LG4M1</code> is rescaled by the rate of the lowest Gamma rate category. The fourth component <code>LG4M4</code> corresponds to the highest rate.</p><p>Note that both <code>frequency</code> and <code>model</code> commands can be embedded into a single model file.</p></classify1>",Mixture models,34.0,34.0,What is the difference between partition and mixture models?
"<classify1 id=""2""><h2 id=""site-specific-frequency-models"">Site-specific frequency models</h2><div class=""hline""></div><p>Starting with version 1.5.0, IQ-TREE provides a new posterior mean site frequency (PMSF) model as a rapid approximation to the time and memory consuming profile mixture models <code>C10</code> to <code>C60</code> (<a href=""https://doi.org/10.1093/bioinformatics/btn445"">Le et al., 2008a</a>; a variant of PhyloBayes’ <code>CAT</code> model). The PMSF are the amino-acid profiles for each alignment site computed from an input mixture model and a guide tree. The PMSF model is much faster and requires much less RAM than <code>C10</code> to <code>C60</code> (see table below), regardless of the number of mixture classes. Our extensive simulations and empirical phylogenomic data analyses demonstrate that the PMSF models can effectively ameliorate long branch attraction artefacts.</p><p>If you use this model in a publication please cite:</p><blockquote><p><strong>H.C. Wang, B.Q. Minh, S. Susko and A.J. Roger</strong> (2018) Modeling site heterogeneity with posterior mean site frequency profiles accelerates accurate phylogenomic estimation. <em>Syst. Biol.</em>, 67:216-235. <a href=""https://doi.org/10.1093/sysbio/syx068"">https://doi.org/10.1093/sysbio/syx068</a></p></blockquote><p>Here is an example of computation time and RAM usage for an Obazoa data set (68 sequences, 43615 amino-acid sites) from <a href=""https://doi.org/10.1098/rspb.2013.1755"">Brown et al. (2013)</a> using 16 CPU cores:</p><table><thead><tr><th>Models</th><th style=""text-align: right"">CPU time</th><th style=""text-align: right"">Wall-clock time</th><th style=""text-align: right"">RAM usage</th></tr></thead><tbody><tr><td><code>LG+F+G</code></td><td style=""text-align: right"">43h:38m:23s</td><td style=""text-align: right"">3h:37m:23s</td><td style=""text-align: right"">1.8 GB</td></tr><tr><td><code>LG+C20+F+G</code></td><td style=""text-align: right"">584h:25m:29s</td><td style=""text-align: right"">46h:39m:06s</td><td style=""text-align: right"">38.8 GB</td></tr><tr><td><code>LG+C60+F+G</code></td><td style=""text-align: right"">1502h:25m:31s</td><td style=""text-align: right"">125h:15m:29s</td><td style=""text-align: right"">112.8 GB</td></tr><tr><td><code>LG+PMSF+G</code></td><td style=""text-align: right"">73h:30m:37s</td><td style=""text-align: right"">5h:7m:27s</td><td style=""text-align: right"">2.2 GB</td></tr></tbody></table><h3 id=""example-usages"">Example usages</h3><p>To use the PMSF model you have to provide a <em>guide tree</em>, which, for example, can be obtained by a quicker analysis under the simpler <code>LG+F+G</code> model. The guide tree can then be specified via <code>-ft</code> option, for example:</p><pre><code>iqtree -s &lt;alignment&gt; -m LG+C20+F+G -ft &lt;guide_tree&gt;
</code></pre><p>Here, IQ-TREE will perform two phases. In the first phase, IQ-TREE estimates mixture model parameters given the guide tree and then infers the site-specific frequency profile (printed to <code>.sitefreq</code> file). In the second phase, IQ-TREE will conduct typical analysis using the inferred frequency model instead of the mixture model to save RAM and running time. Note that without <code>-ft</code> option, IQ-TREE will conduct the analysis under the specified mixture model.</p><p>The PMSF model allows one, for the first time, to conduct nonparametric bootstrap under such complex models, for example (with 100 bootstrap replicates):</p><pre><code>iqtree -s &lt;alignment&gt; -m LG+C20+F+G -ft &lt;guide_tree&gt; -b 100
</code></pre><p>Please note that the first phase still consumes as much RAM as the mixture model. To overcome this, you can perform the first phase in a high-memory server and the second phase in a normal PC as follows:</p><pre><code>iqtree -s &lt;alignment&gt; -m LG+C20+F+G -ft &lt;guide_tree&gt; -n 0
</code></pre><p>This will stop the analysis after the first phase and also write a <code>.sitefreq</code> file. You can now copy this <code>.sitefreq</code> file to another low-memory machine and run with the same alignment:</p><pre><code>iqtree -s &lt;alignment&gt; -m LG+C20+F+G -fs &lt;file.sitefreq&gt; -b 100
</code></pre><p>This will omit the first phase and thus need much less RAM.</p><p>Finally, note that for long (phylogenomic) alignments you can utilize the multicore IQ-TREE version to further save the computing times with, say, 24 cores by:</p><pre><code># For IQ-TREE version &lt;= 1.5.X
iqtree-omp -nt 24 -s &lt;alignment&gt; -m LG+C20+F+G -fs &lt;file.sitefreq&gt;

# For IQ-TREE version &gt;= 1.6.0
iqtree -nt 24 -s &lt;alignment&gt; -m LG+C20+F+G -fs &lt;file.sitefreq&gt;
</code></pre><p>See also <a href=""http://www.iqtree.org/doc/Command-Reference#site-specific-frequency-model-options"">the list of relevant command line options</a>.</p></classify1>",Site-specific frequency models,35.0,35.0,"Starting with version 1.5.0, IQ-TREE provides a new posterior mean site frequency (PMSF) model as a rapid approximation to the time and memory consuming profile mixture models C10 to C60 (Le et al., 2008a; a variant of PhyloBayes’ CAT model). The PMSF are the amino-acid profiles for each alignment site computed from an input mixture model and a guide tree. The PMSF model is much faster and requires much less RAM than C10 to C60 (see table below), regardless of the number of mixture classes. Our extensive simulations and empirical phylogenomic data analyses demonstrate that the PMSF models can effectively ameliorate long branch attraction artefacts."
"<classify1 id=""3""><h2 id=""heterotachy-models"">Heterotachy models</h2><div class=""hline""></div><p>Sequence data that have evolved under <em>heterotachy</em>, i.e., rate variation across sites and lineages (<a href=""http://mbe.oxfordjournals.org/content/19/1/1.full"">Lopez, Casane, and Philippe, 2002</a>), are known to mislead phylogenetic inference (<a href=""https://doi.org/10.1038/nature02917"">Kolaczkowski and Thornton, 2004</a>). To address this issue we introduce the General Heterogeneous evolution On a Single Topology (GHOST) model. More specifically, GHOST is an <em>edge-unlinked mixture model</em> consisting of several site classes, each having a separate set of model parameters and edge lengths on the same tree topology. Thus, GHOST naturally accounts for heterotachous evolution. In contrast to an <a href=""http://www.iqtree.org/doc/Complex-Models#partition-models"">edge-unlinked partition model</a>, the GHOST model does not require the <em>a priori</em> data partitioning, a possible source of model misspecification.</p><p>Extensive simulations show that the GHOST model can accurately recover the tree topology, branch lengths, substitution rate and base frequency parameters from heterotachously-evolved sequences. Moreover, we compare the GHOST model to the partition model and show that, owing to the minimization of model constraints, the GHOST model is able to offer unique biological insights when applied to empirical data.</p><p>If you use this model in a publication please cite:</p><blockquote><p><strong>S.M. Crotty, B.Q. Minh, N.G. Bean, B.R. Holland, J. Tuke, L.S. Jermiin and A. von Haeseler</strong> (2019) GHOST: Recovering historical signal from heterotachously-evolved sequence alignments. <em>Syst. Biol.</em>, in press. <a href=""https://doi.org/10.1093/sysbio/syz051"">https://doi.org/10.1093/sysbio/syz051</a></p></blockquote><h3 id=""quick-usages"">Quick usages</h3><p>Make sure that you have IQ-TREE version 1.6.0 or later. The GHOST model with <code>k</code> mixture classes is executed by adding <code>+Hk</code> to the model option (<code>-m</code>). For example if one wants to fit a GHOST model with 4 classes in conjunction with the <code>GTR</code> model of DNA evolution to sequences contained in <code>data.fst</code>, one would use the following command:</p><pre><code>iqtree -s data.fst -m GTR+H4
</code></pre><p>By default the above command will link GTR parameters across all classes. If you want to unlink GTR parameters, so that IQ-TREE estimates them separately for each class, replace <code>+H4</code> by <code>*H4</code>:</p><pre><code>iqtree -s data.fst -m GTR*H4
</code></pre><p>Note that this infers one set of empirical base frequencies and apply those to all classes. If one wishes to infer separate base frequencies for each class then the <code>+FO</code> option is required:</p><pre><code>iqtree -s data.fst -m GTR+FO*H4
</code></pre><p>The <code>-wspm</code> option will generate a <code>.siteprob</code> output file. This contains the probability of each site belonging to each class:</p><pre><code>iqtree -s data.fst -m GTR+FO*H4 -wspm
</code></pre><div class=""spacing""></div></classify1>",Heterotachy models,36.0,36.0,"Sequence data that have evolved under heterotachy, i.e., rate variation across sites and lineages (Lopez, Casane, and Philippe, 2002), are known to mislead phylogenetic inference (Kolaczkowski and Thornton, 2004). To address this issue we introduce the General Heterogeneous evolution On a Single Topology (GHOST) model. More specifically, GHOST is an edge-unlinked mixture model consisting of several site classes, each having a separate set of model parameters and edge lengths on the same tree topology. Thus, GHOST naturally accounts for heterotachous evolution. In contrast to an edge-unlinked partition model, the GHOST model does not require the a priori data partitioning, a possible source of model misspecification."
"<classify1 id=""0""><h2 id=""inferring-species-tree"">Inferring species tree</h2><p>First, you need to infer a reference tree (e.g. a species tree), on which the concordance factors will be annotated. The species tree can be reconstructed by a concatenation/supermatrix approach or a coalescent/reconciliation/supertree approach. Here, we will use the concatenation approach in IQ-TREE.</p><p>As an example, you can apply an <a href=""http://www.iqtree.org/doc/Complex-Models"">edge-linked proportional partition model</a> with ultrafast bootstrap (1000 replicates; for comparison with concordance factors):</p><pre><code>iqtree -s ALN_FILE -p PARTITION_FILE --prefix concat -B 1000 -T AUTO
</code></pre><p>where <code>ALN_FILE</code> and <code>PARTITION_FILE</code> are your input files. <code>-T AUTO</code> is to detect the best number of CPU cores. Here we use a prefix <code>concat</code>, so that all output files (<code>concat.*</code>) do not interfere with analyses below. If <code>--prefix</code> is omitted, all output files will be <code>PARTITION_FILE.*</code>.</p><p>Moreover, IQ-TREE 2 provides a new convenient feature: if you have a directory with many (locus) alignments, you can specify this directory directly with <code>-p</code> option:</p><pre><code>iqtree -p ALN_DIR --prefix concat -B 1000 -T AUTO
</code></pre><p>IQ-TREE detects if <code>-p</code> argument is a directory and automatically load all alignment files and concatenate them into a supermatrix for the partition analysis.</p></classify1>",Inferring species tree,37.0,37.0,"As an example, you can apply an edge-linked proportional partition model with ultrafast bootstrap (1000 replicates; for comparison with concordance factors):"
"<classify1 id=""1""><h2 id=""inferring-genelocus-trees"">Inferring gene/locus trees</h2><p>We now construct a set of gene/locus trees. One can manually do a for-loop, but IQ-TREE 2 provides a new convenient option <code>-S</code> to compute individual locus trees given a partition file or a directory:</p><pre><code>iqtree -s ALN_FILE -S PARTITION_FILE --prefix loci -T AUTO
# or
iqtree -S ALN_DIR --prefix loci -T AUTO
</code></pre><p>In the second case, IQ-TREE automatically detects that <code>ALN_DIR</code> is a directory and will load all alignment files within the directory. So <code>-S</code> takes the same argument as <code>-p</code> except that it performs model selection (ModelFinder) and tree inference separately for each partition/alignment. The output files are similar to those from a partitioned analysis, except that <code>loci.treefile</code> now contains a set of trees.</p></classify1>",Inferring gene/locus trees,38.0,38.0,"iqtree -s ALN_FILE -S PARTITION_FILE --prefix loci -T AUTO
# or
iqtree -S ALN_DIR --prefix loci -T AUTO
"
"<classify1 id=""2""><h2 id=""gene-concordance-factor-gcf"">Gene concordance factor (gCF)</h2><p>Given the species tree <code>concat.treefile</code> and the set of locus trees <code>loci.treefile</code> computed above, you can calculate gCF for each branch of the species tree as the fraction of decisive gene trees concordant with this branch:</p><pre><code>iqtree -t concat.treefile --gcf loci.treefile --prefix concord
</code></pre><p>Note that <code>-t</code> accepts any reference tree (e.g., by coalescent/reconciliation approach) and <code>--gcf</code> accepts any set of trees (e.g. locus trees and bootstrap trees), which may contain a subset of taxa from the reference tree. IQ-Tree will write three files:</p><ul><li><code>concord.cf.tree</code>: Newick tree with gCF assigned for each internal branch of the reference tree. If the reference tree already has some branch label (such as bootstrap support in this case), gCF will be appended to the existing label separated by a <code>/</code>.</li><li><code>concord.cf.branch</code>: Newick tree with internal branch IDs.</li><li><code>concord.cf.stat</code>: A tab-separated table with gCF and gDF (gene discordance factor) for every internal branch (rows of the table). The ID column can be linked with <code>concord.cf.branch</code> file. This file can be read in R to do some plot (see below).</li></ul><p>If you omit <code>--prefix</code>, all output files will be written to <code>concat.treefile.*</code>.</p></classify1>",Gene concordance factor (gCF),39.0,39.0,"iqtree -t concat.treefile --gcf loci.treefile --prefix concord
"
"<classify1 id=""3""><h2 id=""site-concordance-factor-scf"">Site concordance factor (sCF)</h2><p>Given the species tree <code>concat.treefile</code> and the alignment, you can calculate sCF for each branch of the species tree as the fraction of decisive alignment sites supporting that branch:</p><pre><code>iqtree -t concat.treefile -s ALN_FILE --scf 100 --prefix concord -T 10
</code></pre><p><code>--scf</code> specifies the number of quartets (randomly sampled around each internal branch) for computing sCF. We recommend at least 100 quartets for stable sCF values. Note that running this command several times may lead to slightly different sCF due to randomness. To make it reproducible, you need to use <code>-seed</code> option to provide a random number generator seed.</p><p>Instead of <code>-s</code>, you can alternatively provide a directory or a partition file. IQ-Tree then computes sCF for the concatenated alignment:</p><pre><code>iqtree -t concat.treefile -p ALN_DIR --scf 100 --prefix concord -T 10
</code></pre><p>Finally, you can combine gCF and sCF within a single run:</p><pre><code>iqtree -t concat.treefile --gcf loci.treefile -p ALN_DIR --scf 100 --prefix concord -T 10
</code></pre><p>Here, each branch of <code>concord.cf.tree</code> will be assigned (or appended) with <code>gCF/sCF</code> values and <code>concord.cf.stat</code> will be written with both gCF and sCF values.</p></classify1>",Site concordance factor (sCF),40.0,40.0,"iqtree -t concat.treefile -s ALN_FILE --scf 100 --prefix concord -T 10
"
"<classify1 id=""4""><h2 id=""putting-it-all-together"">Putting it all together</h2><p>If you have separate alignments for each locus in a folder, then perform the following commands:</p><pre><code># infer a concatenation-based species tree with 1000 ultrafast bootstrap and an edge-linked partition model
iqtree -p ALN_DIR --prefix concat -B 1000 -T AUTO

# infer the locus trees
iqtree -S ALN_DIR --prefix loci -T AUTO

# compute concordance factors
iqtree -t concat.treefile --gcf loci.treefile -p ALN_DIR --scf 100 --prefix concord -T 10
</code></pre><p>If you have a single concatenated alignment with a partition file that defines loci:</p><pre><code># infer a concatenation-based species tree with 1000 ultrafast bootstrap and an edge-linked partition model
iqtree -s ALN_FILE -p PARTITION_FILE --prefix concat -B 1000 -T AUTO

# infer the locus trees
iqtree -s ALN_FILE -S PARTITION_FILE --prefix loci -T AUTO

# compute concordance factors
iqtree -t concat.treefile --gcf loci.treefile -s ALN_FILE --scf 100 --prefix concord -T 10
</code></pre><p>Note that you can adjust <code>-T 10</code> if you have fewer/larger CPU cores.</p><div class=""spacing""></div></classify1>",Putting it all together,41.0,41.0,"# infer a concatenation-based species tree with 1000 ultrafast bootstrap and an edge-linked partition model
iqtree -p ALN_DIR --prefix concat -B 1000 -T AUTO

# infer the locus trees
iqtree -S ALN_DIR --prefix loci -T AUTO

# compute concordance factors
iqtree -t concat.treefile --gcf loci.treefile -p ALN_DIR --scf 100 --prefix concord -T 10
"
"<classify1 id=""0""><h2 id=""alignment-class"">Alignment class</h2><div class=""hline""></div><p>The <code>Alignment</code> class stores the data as a <code>vector</code> of <code>Pattern</code>. Each <code>Pattern</code> is in turn a <code>string</code> representing the characters across the sequences at an alignment site, with a <code>frequency</code> of occurrences in the <code>Alignment</code> (from header file <a href=""https://github.com/Cibiv/IQ-TREE/blob/master/pattern.h""><code>pattern.h</code></a>):</p><div class=""language-cpp highlighter-coderay""><div class=""CodeRay""><div class=""code""><pre><span style=""color:#777"">/**
        Site-patterns in a multiple sequence alignment
*/</span>
<span style=""color:#080;font-weight:bold"">class</span> <span style=""color:#B06;font-weight:bold"">Pattern</span> : <span style=""color:#088;font-weight:bold"">public</span> <span style=""color:#0a8;font-weight:bold"">string</span> {
<span style=""color:#088;font-weight:bold"">public</span>:
        ...

        <span style=""color:#777"">/**
                frequency appearance of the pattern
        */</span>
        <span style=""color:#0a8;font-weight:bold"">int</span> frequency;
};
</pre></div></div></div><p>The rationale for storing the data this way (instead of storing a set of sequences) is that most computations are carried out along the site-patterns of the <code>Alignment</code>. Thus, it makes all operations more convenient and faster.</p><p>As noted above, the <code>Alignment</code> class is defined as (from header file <a href=""https://github.com/Cibiv/IQ-TREE/blob/master/alignment.h"">alignment.h</a>):</p><div class=""language-cpp highlighter-coderay""><div class=""CodeRay""><div class=""code""><pre><span style=""color:#777"">/**
    Multiple Sequence Alignment. Stored by a vector of site-patterns
*/</span>
<span style=""color:#080;font-weight:bold"">class</span> <span style=""color:#B06;font-weight:bold"">Alignment</span> : <span style=""color:#088;font-weight:bold"">public</span> vector&lt;Pattern&gt; {
<span style=""color:#088;font-weight:bold"">public</span>:
    <span style=""color:#777"">/**
            constructor
            @param filename file name
            @param sequence_type type of the sequence, either ""BIN"", ""DNA"", ""AA"", or NULL
            @param intype (OUT) input format of the file
     */</span>
    Alignment(<span style=""color:#0a8;font-weight:bold"">char</span> *filename, <span style=""color:#0a8;font-weight:bold"">char</span> *sequence_type, InputType &amp;intype);

    ...
};
</pre></div></div></div><blockquote><p><strong>NOTE</strong>: Please follow the commenting style of the code when declaring new components (classes, functions or variables) like the example above. That way, the source code documentation can be generated with tools like <a href=""http://doxygen.org/"">Doxygen</a>. See <a href=""http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html"">Doxygen commenting manual</a> for more details.</p></blockquote></classify1>",Alignment class,42.0,42.0,"The Alignment class stores the data as a vector of Pattern. Each Pattern is in turn a string representing the characters across the sequences at an alignment site, with a frequency of occurrences in the Alignment (from header file pattern.h):"
"<classify1 id=""1""><h2 id=""model-of-substitution"">Model of substitution</h2><div class=""hline""></div><h3 id=""modelsubst"">ModelSubst</h3><p><code>ModelSubst</code> is the base class for all substitution models implemented in IQ-TREE. It implements the basic Juke-Cantor-type model (equal substitution rates and equal state frequencies) that works for all data type. <code>ModelSubst</code> class declares a number of <code>virtual</code> methods, that need to be overriden when implementing a new model, for example (from header file <a href=""https://github.com/Cibiv/IQ-TREE/blob/master/model/modelsubst.h"">model/modelsubst.h</a>):</p><div class=""language-cpp highlighter-coderay""><div class=""CodeRay""><div class=""code""><pre><span style=""color:#777"">/**
    Substitution model abstract class
*/</span>
<span style=""color:#080;font-weight:bold"">class</span> <span style=""color:#B06;font-weight:bold"">ModelSubst</span>: <span style=""color:#088;font-weight:bold"">public</span> Optimization
{
<span style=""color:#088;font-weight:bold"">public</span>:
        <span style=""color:#777"">/**
                constructor
                @param nstates number of states, e.g. 4 for DNA, 20 for proteins.
        */</span>
    ModelSubst(<span style=""color:#0a8;font-weight:bold"">int</span> nstates);

        <span style=""color:#777"">/**
                @return the number of dimensions
        */</span>
        <span style=""color:#088;font-weight:bold"">virtual</span> <span style=""color:#0a8;font-weight:bold"">int</span> getNDim() { <span style=""color:#080;font-weight:bold"">return</span> <span style=""color:#00D"">0</span>; }

    ...
};
</pre></div></div></div><p>As an example, the method <code>getNDim()</code> should return the number of free parameters of the model, which is 0 for the default JC-type model.</p><h3 id=""modelgtr"">ModelGTR</h3><p><code>ModelGTR</code> class extends <code>ModelSubst</code> and implements the general time reversible model. <code>ModelGTR</code> is the base class for all models currently used in IQ-TREE. Some important ingredients of <code>ModelGTR</code> (from <a href=""https://github.com/Cibiv/IQ-TREE/blob/master/model/modelgtr.h"">model/modelgtr.h</a>):</p><div class=""language-cpp highlighter-coderay""><div class=""CodeRay""><div class=""code""><pre><span style=""color:#777"">/**
    General Time Reversible (GTR) model of substitution.
    This works for all kind of data, not only DNA
*/</span>
<span style=""color:#080;font-weight:bold"">class</span> <span style=""color:#B06;font-weight:bold"">ModelGTR</span> : <span style=""color:#088;font-weight:bold"">public</span> ModelSubst, <span style=""color:#088;font-weight:bold"">public</span> EigenDecomposition
{
<span style=""color:#088;font-weight:bold"">public</span>:
        <span style=""color:#777"">/**
                constructor
                @param tree associated tree for the model
        */</span>
    ModelGTR(PhyloTree *tree, <span style=""color:#0a8;font-weight:bold"">bool</span> count_rates = <span style=""color:#069"">true</span>);

        <span style=""color:#777"">/**
                @return the number of dimensions
        */</span>
        <span style=""color:#088;font-weight:bold"">virtual</span> <span style=""color:#0a8;font-weight:bold"">int</span> getNDim();
    ...

<span style=""color:#088;font-weight:bold"">protected</span>:
    <span style=""color:#777"">/**
                rates between pairs of states of the unit rate matrix Q.
                In order A-C, A-G, A-T, C-G, C-T (rate G-T = 1 always)
        */</span>
        <span style=""color:#0a8;font-weight:bold"">double</span> *rates;
    ....
};
</pre></div></div></div></classify1>",Model of substitution,43.0,43.0,ModelSubst
"<classify1 id=""2""><h2 id=""phylotree-class-phylogenetic-tree"">PhyloTree class (phylogenetic tree)</h2><div class=""hline""></div><p><code>PhyloTree</code> is the base class for phylogenetic trees.</p><div class=""spacing""></div></classify1>",PhyloTree class (phylogenetic tree),44.0,44.0,PhyloTree is the base class for phylogenetic trees.
"<classify1 id=""0""><h2 id=""how-do-i-get-help"">How do I get help?</h2><div class=""hline""></div><p>If you have questions please follow the steps below:</p><ol><li>Continue to read the FAQ below, which may answer your questions already.</li><li>If not, read the documentation <a href=""http://www.iqtree.org/doc"">http://www.iqtree.org/doc</a>.</li><li>If you still could not find the answer, search the <a href=""https://groups.google.com/d/forum/iqtree"">IQ-TREE Google group</a>. There is a “Search for topics” box at the top of the Google group web page.</li><li>Finally, if no answer is found, post a question to the IQ-TREE group. The average response time is one to two working days.</li></ol><blockquote><p>For other feedback and feature request, please post a topic to the <a href=""https://groups.google.com/d/forum/iqtree"">IQ-TREE Google group</a>. We welcome all suggestions to further improve IQ-TREE! For feature request, please also explain why you think such a new feature would be useful or how can it help for your work.</p></blockquote></classify1>",How do I get help?,45.0,45.0,If you have questions please follow the steps below:
"<classify1 id=""1""><h2 id=""how-do-i-report-bug"">How do I report bug?</h2><div class=""hline""></div><p>For bug report, please send the following information to the <a href=""https://groups.google.com/d/forum/iqtree"">IQ-TREE Google group</a>:</p><ol><li>A description of the behaviour, which you think might be unexpected or caused by a bug.</li><li>The first 10 lines and last 10 lines of the <code>.log</code> file.</li><li><p>(If possible) the assertion message printed on the screen, which may look like this:</p><pre><code> iqtree: ....cpp:140: ...: Assertion '...' failed.
</code></pre></li></ol><p>The development team will get back to you and may ask for the full <code>.log</code> file and input data files for debugging purpose, if necessary. In such case please <strong>only send your data files directly to the developers for confidential reason</strong>! Keep in mind that everyone can see all emails sent to the group!</p></classify1>",How do I report bug?,46.0,46.0,"For bug report, please send the following information to the IQ-TREE Google group:"
"<classify1 id=""2""><h2 id=""how-do-i-interpret-ultrafast-bootstrap-ufboot-support-values"">How do I interpret ultrafast bootstrap (UFBoot) support values?</h2><div class=""hline""></div><p>The ultrafast bootstrap (UFBoot) feature (<code>-bb</code> option) was published in (<a href=""https://doi.org/10.1093/molbev/mst024"">Minh et al., 2013</a>). One of the main conclusions is, that UFBoot support values are more unbiased: 95% support correspond roughly to a probability of 95% that a clade is true. So this has a different meaning than the normal bootstrap supports (where you start to believe in the clade if it has &gt;80% BS support). For UFBoot, you should only start to believe in a clade if its support is &gt;= 95%. Thus, the interpretations are different and you should not compare BS% with UFBoot% directly.</p><p>Moreover, it is recommended to also perform the SH-aLRT test (<a href=""https://doi.org/10.1093/sysbio/syq010"">Guindon et al., 2010</a>) by adding <code>-alrt 1000</code> into the IQ-TREE command line. Each branch will then be assigned with SH-aLRT and UFBoot supports. One would typically start to rely on the clade if its SH-aLRT &gt;= 80% and UFboot &gt;= 95%.</p></classify1>",How do I interpret ultrafast bootstrap (UFBoot) support values?,47.0,47.0,"The ultrafast bootstrap (UFBoot) feature (-bb option) was published in (Minh et al., 2013). One of the main conclusions is, that UFBoot support values are more unbiased: 95% support correspond roughly to a probability of 95% that a clade is true. So this has a different meaning than the normal bootstrap supports (where you start to believe in the clade if it has >80% BS support). For UFBoot, you should only start to believe in a clade if its support is >= 95%. Thus, the interpretations are different and you should not compare BS% with UFBoot% directly."
"<classify1 id=""3""><h2 id=""how-does-iq-tree-treat-gapmissingambiguous-characters"">How does IQ-TREE treat gap/missing/ambiguous characters?</h2><div class=""hline""></div><p>Gaps (<code>-</code>) and missing characters (<code>?</code> or <code>N</code> for DNA alignments) are treated in the same way as <code>unknown</code> characters, which represent no information. The same treatment holds for many other ML software (e.g., RAxML, PhyML). More explicitly, for a site (column) of an alignment containing <code>AC-AG-A</code> (i.e. A for sequence 1, C for sequence 2, <code>-</code> for sequence 3, and so on), the site-likelihood of a tree T is equal to the site-likelihood of the subtree of T restricted to those sequences containing non-gap characters (<code>ACAGA</code>).</p><p>Ambiguous characters that represent more than one character are also supported: each represented character will have equal likelihood. For DNA the following ambigous nucleotides are supported according to <a href=""https://en.wikipedia.org/wiki/Nucleic_acid_notation"">IUPAC nomenclature</a>:</p><table><thead><tr><th>Nucleotide</th><th>Meaning</th></tr></thead><tbody><tr><td>R</td><td>A or G (purine)</td></tr><tr><td>Y</td><td>C or T (pyrimidine)</td></tr><tr><td>W</td><td>A or T (weak)</td></tr><tr><td>S</td><td>G or C (strong)</td></tr><tr><td>M</td><td>A or C (amino)</td></tr><tr><td>K</td><td>G or T (keto)</td></tr><tr><td>B</td><td>C, G or T (next letter after A)</td></tr><tr><td>H</td><td>A, C or T (next letter after G)</td></tr><tr><td>D</td><td>A, G or T (next letter after C)</td></tr><tr><td>V</td><td>A, G or C (next letter after T)</td></tr><tr><td>?, -, ., ~, O, N, X</td><td>A, G, C or T (unknown; all 4 nucleotides are equally likely)</td></tr></tbody></table><p>For protein the following ambiguous amino-acids are supported:</p><table><thead><tr><th>Amino-acid</th><th>Meaning</th></tr></thead><tbody><tr><td>B</td><td>N or D</td></tr><tr><td>Z</td><td>Q or E</td></tr><tr><td>J</td><td>I or L</td></tr><tr><td>U</td><td>unknown AA (although it is the 21st AA)</td></tr><tr><td>?, -, ., ~, * or X</td><td>unknown AA (all 20 AAs are equally likely)</td></tr></tbody></table></classify1>",How does IQ-TREE treat gap/missing/ambiguous characters?,48.0,48.0,"Gaps (-) and missing characters (? or N for DNA alignments) are treated in the same way as unknown characters, which represent no information. The same treatment holds for many other ML software (e.g., RAxML, PhyML). More explicitly, for a site (column) of an alignment containing AC-AG-A (i.e. A for sequence 1, C for sequence 2, - for sequence 3, and so on), the site-likelihood of a tree T is equal to the site-likelihood of the subtree of T restricted to those sequences containing non-gap characters (ACAGA)."
"<classify1 id=""4""><h2 id=""can-i-mix-dna-and-protein-data-in-a-partitioned-analysis"">Can I mix DNA and protein data in a partitioned analysis?</h2><div class=""hline""></div><p>Yes! You can specify this via a NEXUS partition file. In fact, you can mix any data types supported in IQ-TREE, including also codon, binary and morphological data. To do so, each data type should be stored in a separate alignment file (see also <a href=""http://www.iqtree.org/doc/Advanced-Tutorial#partitioned-analysis-with-mixed-data"">Partitioned analysis with mixed data</a>). As an example, assuming <code>dna.phy</code> is a DNA alignment and and <code>prot.phy</code> is a protein alignment. Then a partition file mixing two types of data can be specified as follows:</p><pre><code>#nexus
begin sets;
    charset part1 = dna.phy: 1-100 201-300;
    charset part2 = dna.phy: 101-200;
    charset part3 = prot.phy: 1-150;
    charset part4 = prot.phy: 151-400;
    charpartition mine = HKY:part1, GTR+G:part2, WAG+I+G:part3, LG+G:part4;
end;
</code></pre><blockquote><p><strong>NOTE</strong>: The site count for each alignment should start from 1, and <strong>not</strong> continue from the last position of a previous alignment (e.g., see <code>part3</code> and <code>part4</code> declared above).</p></blockquote></classify1>",Can I mix DNA and protein data in a partitioned analysis?,49.0,49.0,"Yes! You can specify this via a NEXUS partition file. In fact, you can mix any data types supported in IQ-TREE, including also codon, binary and morphological data. To do so, each data type should be stored in a separate alignment file (see also Partitioned analysis with mixed data). As an example, assuming dna.phy is a DNA alignment and and prot.phy is a protein alignment. Then a partition file mixing two types of data can be specified as follows:"
"<classify1 id=""5""><h2 id=""what-is-the-interpretation-of-branch-lengths-when-mixing-codon-and-dna-data"">What is the interpretation of branch lengths when mixing codon and DNA data?</h2><div class=""hline""></div><p>When mixing codon and DNA data in a partitioned analysis, the branch lengths are interpreted as the number of nucleotide substitutions per nucleotide site! This is different from having only codon data, where branch lengths are the number of nucleotide substitutions per codon site (thus typically 3 times longer than under DNA models).</p><p>Note that if you mix codon, DNA and protein data, the branch lengths are then the number of character substitutions per site, where character is either nucleotide or amino-acid.</p></classify1>",What is the interpretation of branch lengths when mixing codon and DNA data?,50.0,50.0,"When mixing codon and DNA data in a partitioned analysis, the branch lengths are interpreted as the number of nucleotide substitutions per nucleotide site! This is different from having only codon data, where branch lengths are the number of nucleotide substitutions per codon site (thus typically 3 times longer than under DNA models)."
"<classify1 id=""6""><h2 id=""what-is-the-purpose-of-composition-test"">What is the purpose of composition test?</h2><div class=""hline""></div><p>At the beginning of each run, IQ-TREE performs a composition chi-square test for every sequence in the alignment. The purpose is to test for homogeneity of character composition (e.g., nucleotide for DNA, amino-acid for protein sequences). A sequence is denoted <code>failed</code> if its character composition significantly deviates from the average composition of the alignment.</p><p>More specifically, for each sequence, compute:</p><pre><code>chi2 = \sum_{i=1}^k (O_i - E_i)^2 / E_i
</code></pre><p>where k is the size of the alphabet (e.g. 4 for DNA, 20 for amino acids) and the values 1 to k correspond uniquely to one of the characters. O_i is the character frequency in the sequence tested. E_i is the overall character frequency from the entire alignment.</p><p>Whether the character composition deviates significantly from the overall composition is done by testing the chi2 value using the chi2-distribution with k-1 degrees of freedom (df=3 for DNA or df=19 for amino acids). By and large it is a normal Chi^2 test.</p><p>This test should be regarded as an <em>explorative tool</em> which might help to nail down problems in a dataset. One would typically not remove failing sequences by default. But if the tree shows unexpected topology the test might point in direction of the origin of the problem.</p><p>Furthermore, please keep in mind, this test is performed at the very beginning, where IQ-TREE does not know anything about the models yet. That means:</p><ul><li>If you have partitioned (multi-gene) data, it might be more reasonable to test this separately for each partition in a partition analysis. Here, one might want to be able to decide whether some partitions should better be discarded if it is hard to find a composition representing the sequences in the partition. Or on the other hand if a sequence fails for many partitions and show very unexpected phylogenetic topologies, try without it.</li><li>If you have (phylogenomic) protein data, you can also try several <a href=""http://www.iqtree.org/doc/Substitution-Models#protein-mixture-models"">protein mixture models</a>, which account for different amino-acid compositions along the sequences, for example, the <code>C10</code> to <code>C60</code> profile mixture models.</li><li>Finally, it is recommended to always check the alignment (something one should always do anyway), especially if they have been collected and produced automatically.</li></ul></classify1>",What is the purpose of composition test?,51.0,51.0,"At the beginning of each run, IQ-TREE performs a composition chi-square test for every sequence in the alignment. The purpose is to test for homogeneity of character composition (e.g., nucleotide for DNA, amino-acid for protein sequences). A sequence is denoted failed if its character composition significantly deviates from the average composition of the alignment."
"<classify1 id=""7""><h2 id=""what-is-the-good-number-of-cpu-cores-to-use"">What is the good number of CPU cores to use?</h2><div class=""hline""></div><p>Starting with version 1.5.1, you can use option <code>-nt AUTO</code> to automatically determine the best number of threads for your current data and computer.</p><p>If you want to know more details: IQ-TREE can utilize multicore machines to speed up the analysis via <code>-nt</code> option. However, it does not mean that using more cores will always result in less running time: if your alignment is short, using too many cores may even slow down the analysis. This is because IQ-TREE parallelizes the likelihood computation along the alignment. Thus, the parallel efficiency is only increased with longer alignments.</p><p>If you want to restrict the number of CPU cores allocated by <code>-nt AUTO</code> use <code>-ntmax</code> to specify the maximal number of CPU cores allowed (DEFAULT: #CPU cores on the current machine).</p></classify1>",What is the good number of CPU cores to use?,52.0,52.0,"Starting with version 1.5.1, you can use option -nt AUTO to automatically determine the best number of threads for your current data and computer."
"<classify1 id=""8""><h2 id=""how-do-i-save-time-for-standard-bootstrap"">How do I save time for standard bootstrap?</h2><div class=""hline""></div><p>The standard bootstrap is rather slow and may take weeks/months for large data sets. One way to speed up is to use the multicore version. However, this only works well for long alignments (see <a href=""http://www.iqtree.org/doc/Frequently-Asked-Questions#what-is-the-good-number-of-cpu-cores-to-use"">What is the good number of CPU cores to use?</a>). Another way is to use many machines or a computing cluster and split the computation among the machines. To illustrate, you want to perform 100 bootstrap replicates and have 5 PCs, each has 4 CPU cores. Then you can:</p><ol><li><p>Perform 5 independent bootstrap runs (each with 20 replicates) on the 5 machines with 5 prefix outputs (such that output files are not overwritten). For example:</p><pre><code> # For old IQ-TREE versions &lt;= 1.5.X, change iqtree to iqtree-omp
 iqtree -nt 4 -s input_alignment -bo 20 ... -pre boot1
 iqtree -nt 4 -s input_alignment -bo 20 ... -pre boot2
 iqtree -nt 4 -s input_alignment -bo 20 ... -pre boot3
 iqtree -nt 4 -s input_alignment -bo 20 ... -pre boot4
 iqtree -nt 4 -s input_alignment -bo 20 ... -pre boot5
</code></pre><p>Note that if you have access to a computing cluster, you may want to submit these jobs onto the cluster queue in parallel and with even more fined grained parallelization (e.g. one replicate per job).</p></li><li><p>Once all 5 runs finished, combine the 5 <code>.boottrees</code> file into one file (e.g. by <code>cat</code> command under Linux):</p><pre><code> cat boot*.boottrees &gt; alltrees
</code></pre></li><li><p>Construct a consensus tree from the combined bootstrap trees:</p><pre><code> iqtree -con -t alltrees
</code></pre><p>The consensus tree is then written to <code>.contree</code> file.</p></li><li><p>Estimate branch lengths of the consensus tree using the original alignment:</p><pre><code> iqtree -s input_alignment -te alltrees.contree -pre alltrees.contree
</code></pre></li><li><p>You can also perform the analysis on the original alignment:</p><pre><code> # For old IQ-TREE versions &lt;= 1.5.X, change iqtree to iqtree-omp
 iqtree -nt 4 -s input_alignment ...
</code></pre><p>and map the support values onto the obtained ML tree:</p><pre><code> iqtree -sup input_alignment.treefile -t alltrees 
</code></pre><p>The ML tree with assigned bootstrap supports is written to <code>.suptree</code> file.</p></li></ol></classify1>",How do I save time for standard bootstrap?,53.0,53.0,"The standard bootstrap is rather slow and may take weeks/months for large data sets. One way to speed up is to use the multicore version. However, this only works well for long alignments (see What is the good number of CPU cores to use?). Another way is to use many machines or a computing cluster and split the computation among the machines. To illustrate, you want to perform 100 bootstrap replicates and have 5 PCs, each has 4 CPU cores. Then you can:"
"<classify1 id=""9""><h2 id=""why-does-iq-tree-complain-about-the-use-of-asc-model"">Why does IQ-TREE complain about the use of +ASC model?</h2><div class=""hline""></div><p>When using ascertainment bias correction (ASC) model, sometimes you may get an error message:</p><p><code>ERROR: Invaid use of +ASC because of ... invariant sites in the alignment</code></p><p>or when performing model testing:</p><p><code>Skipped since +ASC is not applicable</code></p><p>This is because your alignment contains <em>invariant</em> sites (columns), which violate the mathematical condition of the model. The invariant sites can be:</p><ul><li>Constant sites: containing a single character state over all sequences. For example, all sequences show an <code>A</code> (Adenine) at a particular site in a DNA alignment.</li><li>Partially constant sites: containing a single character, gap or unknown character. For example, at a particular site some sequences show a <code>G</code> (Guanine), some sequences have <code>-</code> (gap) and the other have <code>N</code>.</li><li>Ambiguously constant sites: For example, some sequences show a <code>C</code> (Cytosine), some show a <code>Y</code> (meaning <code>C</code> or <code>T</code>) and some show a <code>-</code> (gap).</li></ul><p>All these sites must be removed from the alignment before a +ASC model can be applied.</p><blockquote class=""tip""><p><strong>TIP</strong>: Starting with IQ-TREE version 1.5.0, an output alignment file with suffix <code>.varsites</code> is written in such cases, which contain only variable sites from the input alignment. The <code>.varsites</code> alignment can then be used with the +ASC model.</p></blockquote></classify1>",Why does IQ-TREE complain about the use of +ASC model?,54.0,54.0,"When using ascertainment bias correction (ASC) model, sometimes you may get an error message:"
"<classify1 id=""10""><h2 id=""how-does-iq-tree-treat-identical-sequences"">How does IQ-TREE treat identical sequences?</h2><p>Among a group of identical sequences, IQ-TREE will keep the first two and ignore the rest. If the sequence is the 2nd one, it will be “kept for subsequent analysis”. If it is the 3rd or more, it will be “ignored but added at the end”. The rationale for this is to still be able to calculate the bootstrap support for this group of identical sequences: it is not always 100%. Because by bootstrap resampling, on average only two third of the sites will be present in a bootstrap alignment (due to sampling with replacement), and suddenly another sequence not in this group may actually become identical to this group of sequences. In that case, the bootstrap value will be &lt; 100%.</p><p>Therefore, the <code>.uniqueseq.phy</code> printed by IQ-TREE may still contain the identical sequences, but no more than two of each identical group.</p></classify1>",How does IQ-TREE treat identical sequences?,55.0,55.0,"Therefore, the .uniqueseq.phy printed by IQ-TREE may still contain the identical sequences, but no more than two of each identical group."
"<classify1 id=""11""><h2 id=""what-are-the-differences-between-alignment-columnssites-and-patterns"">What are the differences between alignment columns/sites and patterns?</h2><p>Columns are the columns/sites in the alignment and the number of columns is the length of the alignment. In the alignment there might be the same columns. Different columns are called patterns. While (parsimony) informative sites are patterns that have at least two different characters (nucleotides or amino acids) and each character should occur in at least two species. Essentially, informative sites have information for the grouping of species. These patterns are mainly important in the context of parsimony, where no evolutionary model is used. In maximum likelihood inference all patterns containing different characters are important for the estimation of tree topology and branch lengths, while constant/invariant sites (containing only the same character: only A’s or only G’s etc) are important for the correct estimation of the branch lengths. Therefore, should not be excluded from the alignment.</p><p>Example:</p><pre><code>            123456789
species_1   AACGTACGT
species_2   AACGATCGT
species_3   AACCGTCCT
species_4   AACCTACCT
</code></pre><ul><li>sites/columns 1 and 2 are identical and contain only A’s - invariant site pattern, uninformative</li><li>sites/columns 3 and 7 are identical and contain only C’s - invariant site pattern, uninformative</li><li>sites/columns 4 and 8 are identical and contain 2 G’c and 2 C’s - informative site pattern</li><li>sites/columns 5, 6 and 9 occur only once, each site is a different pattern. 5th is uninformative, 6th is informative, 9th is invariant and uninformative</li></ul><p>Summing up, the alignment has 9 columns,</p><p>6 patterns</p><pre><code>A C G T A T
A C G A T T
A C C G T T
A C C T A T
</code></pre><p>(2 informative)</p><pre><code>G A 
G T 
C T 
C A
</code></pre><div class=""spacing""></div></classify1>",What are the differences between alignment columns/sites and patterns?,56.0,56.0,Example:
"<classify1 id=""0""><h2 id=""iq-tree-web-server"">IQ-TREE web server</h2><div class=""hline""></div><p>The quickest is to try out the <a href=""http://iqtree.cibiv.univie.ac.at/"">IQ-TREE web server</a>, where you only need to upload an alignment, choose the options and start the analysis. There is a <a href=""http://www.iqtree.org/doc/Web-Server-Tutorial"">web server tutorial here</a>.</p><p>If you want to use the command-line version, follow the instructions below.</p></classify1>",IQ-TREE web server,57.0,57.0,"The quickest is to try out the IQ-TREE web server, where you only need to upload an alignment, choose the options and start the analysis. There is a web server tutorial here."
"<classify1 id=""1""><h2 id=""installation"">Installation</h2><div class=""hline""></div><p>For reasons of performance, IQ-TREE is a command-line program, i.e., IQ-TREE needs to be run from a terminal/console (command prompt under Windows).</p><h3 id=""packages-and-bundles"">Packages and bundles</h3><p>Ready made IQ-TREE packages are available for the following distributions/repositories (command to install iqtree):</p><ul><li><a href=""https://packages.debian.org/unstable/science/iqtree"">Debian Linux</a>: <code>sudo apt-get install iqtree</code></li><li><a href=""https://aur.archlinux.org/packages/iqtree-latest/"">Arch Linux (AUR)</a></li><li><a href=""https://anaconda.org/bioconda/iqtree"">Anaconda</a>: <code>conda install -c bioconda iqtree</code></li><li><a href=""https://github.com/brewsci/homebrew-bio/blob/master/Formula/iqtree.rb"">Homebrew</a>: <code>brew install brewsci/bio/iqtree2</code></li><li><a href=""https://www.freshports.org/biology/iqtree/"">FreeBSD</a>: <code>pkg install iqtree</code></li></ul><h3 id=""manual-download"">Manual download</h3><p>IQ-TREE for Windows, MacOSX and Linux can be <a href=""http://www.iqtree.org/#download"">downloaded here</a>.</p><ul><li>Extract the <code>.zip</code> (Windows, MacOSX) or <code>.tar.gz</code> (Linux) file to create a directory <code>iqtree-X.Y.Z-OS</code>, where <code>X.Y.Z</code> is the version number and <code>OS</code> is the operating system (Windows, MacOSX or Linux).</li><li>You will find the executable in the <code>bin</code> sub-folder. Copy all files in <code>bin</code> folder to your system search path such that you can run IQ-TREE by entering <code>iqtree</code> from the Terminal.</li></ul><p>Now you need to open a Terminal (or Console) to run IQ-TREE. See below the guide for <a href=""http://www.iqtree.org/doc/Quickstart#for-windows-users"">Windows users</a> and <a href=""http://www.iqtree.org/doc/Quickstart#for-mac-os-x-users"">Mac OS X users</a>.</p></classify1>",Installation,58.0,58.0,"For reasons of performance, IQ-TREE is a command-line program, i.e., IQ-TREE needs to be run from a terminal/console (command prompt under Windows)."
"<classify1 id=""2""><h2 id=""for-windows-users"">For Windows users</h2><div class=""hline""></div><p>Since IQ-TREE is a command-line program, clicking on <code>iqtree.exe</code> will not work. You have to open a Command Prompt for all analyses:</p><ol><li>Click on “Start” menu (below left corner of Windows screen).</li><li>Type in “cmd” and press “Enter”. It will open the Command Prompt window (see Figure below).</li><li><p>Go into IQ-TREE folder you just extracted by entering e.g. (assuming you downloaded version 1.5.0):</p><pre><code> cd Downloads\iqtree-1.5.0-Windows
</code></pre><p>(assuming that IQ-TREE was downloaded into <code>Downloads</code> folder).</p></li><li><p>Now you can try an example run by entering:</p><pre><code> bin\iqtree -s example.phy
</code></pre><p>(<code>example.phy</code> is the example PHYLIP alignment file also extracted in that folder).</p></li><li>After a few seconds, IQ-TREE finishes and you may see something like this:</li></ol><p><img alt=""Windows command prompt"" src=""./Getting Started_files/win-cmd2.png""/></p><p>Congratulations ;-) You have finished the first IQ-TREE analysis.</p></classify1>",For Windows users,59.0,59.0,"Since IQ-TREE is a command-line program, clicking on iqtree.exe will not work. You have to open a Command Prompt for all analyses:"
"<classify1 id=""3""><h2 id=""for-mac-os-x-users"">For Mac OS X users</h2><div class=""hline""></div><ol><li>Open the “Terminal”, e.g., by clicking on the Spotlight icon (top-right corner), typing “terminal” and press “Enter”.</li><li><p>Go into IQ-TREE folder by entering (assuming you downloaded version 1.5.0):</p><pre><code> cd Downloads/iqtree-1.5.0-MacOSX
</code></pre><p>(assuming that IQ-TREE was downloaded into <code>Downloads</code> folder).</p></li><li><p>Now you can try an example run by entering</p><pre><code> bin/iqtree -s example.phy
</code></pre><p>(<code>example.phy</code> is the example PHYLIP alignment file also extracted in that folder).</p></li><li>After a few seconds, IQ-TREE finishes and you may see something like this:</li></ol><p><img alt=""Mac terminal"" src=""./Getting Started_files/mac-cmd2.png""/></p><p>Congratulations ;-) You have finished the first IQ-TREE analysis.</p></classify1>",For Mac OS X users,60.0,60.0,"Open the “Terminal”, e.g., by clicking on the Spotlight icon (top-right corner), typing “terminal” and press “Enter”.Go into IQ-TREE folder by entering (assuming you downloaded version 1.5.0): cd Downloads/iqtree-1.5.0-MacOSX
(assuming that IQ-TREE was downloaded into Downloads folder).Now you can try an example run by entering bin/iqtree -s example.phy
(example.phy is the example PHYLIP alignment file also extracted in that folder).After a few seconds, IQ-TREE finishes and you may see something like this:"
"<classify1 id=""4""><h2 id=""minimal-command-line-examples"">Minimal command-line examples</h2><div class=""hline""></div><p>A few typically analyses are listed in the following. Note that it is assumed that <code>iqtree</code> executable was already copied into system search path. If not, please replace <code>iqtree</code> with actual path to executable.</p><ul><li><p>Infer maximum-likelihood tree from a sequence alignment (<code>example.phy</code>) with the best-fit model automatically selected by ModelFinder:</p><pre><code>  iqtree -s example.phy
</code></pre></li><li><p>Infer maximum-likelihood tree using <code>GTR+I+G</code> model:</p><pre><code>  iqtree -s example.phy -m GTR+I+G
</code></pre></li><li><p>Perform ModelFinder without subsequent tree inference:</p><pre><code>  iqtree -s example.phy -m MF
</code></pre></li><li><p>Combine ModelFinder, tree search, SH-aLRT test and ultrafast bootstrap with 1000 replicates:</p><pre><code>  iqtree -s example.phy -B 1000 -alrt 1000
  # for version 1.x, change -B to -bb
</code></pre></li><li><p>Perform edge-linked proportional partition model (<code>example.nex</code>):</p><pre><code>  iqtree -s example.phy -p example.nex
  # for version 1.x change -p to -spp
</code></pre></li><li><p>Find best partition scheme by possibly merging partitions:</p><pre><code>  iqtree -s example.phy -p example.nex -m MF+MERGE
</code></pre></li><li><p>Find best partition scheme followed by tree inference and ultrafast bootstrap:</p><pre><code>  iqtree -s example.phy -p example.nex -m MFP+MERGE -B 1000
  # for version 1.x change -B to -bb
</code></pre></li><li><p>Use 4 CPU cores to speed up computation:</p><pre><code>  iqtree -s example.phy -T 4
  # for version 1.x change -T to -nt
</code></pre></li><li><p>Determine the best number of cores to use under <code>GTR+R4</code> model:</p><pre><code>  iqtree -s example.phy -m GTR+R4 -T AUTO
  # for version 1.x change -T to -nt
</code></pre></li><li><p>Show all available options:</p><pre><code>  iqtree -h
</code></pre></li></ul></classify1>",Minimal command-line examples,61.0,61.0,"A few typically analyses are listed in the following. Note that it is assumed that iqtree executable was already copied into system search path. If not, please replace iqtree with actual path to executable."
"<classify1 id=""5""><h2 id=""where-to-go-from-here"">Where to go from here?</h2><div class=""hline""></div><p>Please continue with the <strong><a href=""http://www.iqtree.org/doc/Tutorial"">Beginner’s tutorial</a></strong> for further usages.</p><div class=""spacing""></div></classify1>",Where to go from here?,62.0,62.0,Please continue with the Beginner’s tutorial for further usages.
"<classify1 id=""0""><h2 id=""why-iq-tree"">Why IQ-TREE?</h2><div class=""hline""></div><p>Thanks to the recent advent of next-generation sequencing techniques, the amount of phylogenomic/transcriptomic data have been rapidly accumulated. This extremely facilitates resolving many “deep phylogenetic” questions in the tree of life. At the same time it poses major computational challenges to analyze such big data, where most phylogenetic software cannot handle. Moreover, there is a need to develop more complex probabilistic models to adequately capture realistic aspects of genomic sequence evolution.</p><p>This trends motivated us to develop the IQ-TREE software with a strong emphasis on phylogenomic inference. Our goals are:</p><ul><li><strong>Accuracy</strong>: Proposing novel computational methods that perform better than existing approaches.</li><li><strong>Speed</strong>: Allowing fast analysis on big data sets and utilizing high performance computing platforms.</li><li><strong>Flexibility</strong>: Facilitating the inclusion of new (phylogenomic) models and sequence data types.</li><li><strong>Versatility</strong>: Implementing a broad range of commonly-used maximum likelihood analyses.</li></ul><p>IQ-TREE has been developed since 2011 and freely available at <a href=""http://www.iqtree.org/"">http://www.iqtree.org/</a> as open-source software under the <a href=""http://www.gnu.org/licenses/licenses.en.html"">GNU-GPL license version 2</a>. It is actively maintained by the core development team (see below) and a number of collabrators.</p><p>The name IQ-TREE comes from the fact that it is the successor of <a href=""http://www.cibiv.at/software/iqpnni/""><strong>IQ</strong>PNNI</a> and <a href=""http://www.tree-puzzle.de/""><strong>TREE</strong>-PUZZLE</a> software.</p></classify1>",Why IQ-TREE?,63.0,63.0,"Thanks to the recent advent of next-generation sequencing techniques, the amount of phylogenomic/transcriptomic data have been rapidly accumulated. This extremely facilitates resolving many “deep phylogenetic” questions in the tree of life. At the same time it poses major computational challenges to analyze such big data, where most phylogenetic software cannot handle. Moreover, there is a need to develop more complex probabilistic models to adequately capture realistic aspects of genomic sequence evolution."
"<classify1 id=""1""><h2 id=""key-features"">Key features</h2><div class=""hline""></div><ul><li><strong>Efficient search algorithm</strong>: Fast and effective stochastic algorithm to reconstruct phylogenetic trees by maximum likelihood. IQ-TREE compares favorably to RAxML and PhyML in terms of likelihood while requiring similar amount of computing time (<a href=""https://doi.org/10.1093/molbev/msu300"">Nguyen et al., 2015</a>).</li><li><strong>Ultrafast bootstrap</strong>: An ultrafast bootstrap approximation (UFBoot) to assess branch supports. UFBoot is 10 to 40 times faster than RAxML rapid bootstrap and obtains less biased support values (<a href=""https://doi.org/10.1093/molbev/mst024"">Minh et al., 2013</a>; <a href=""https://doi.org/10.1093/molbev/msx281"">Hoang et al., 2018</a>).</li><li><strong>Ultrafast model selection</strong>: An ultrafast and automatic model selection (ModelFinder) which is 10 to 100 times faster than jModelTest and ProtTest. ModelFinder also finds best-fit partitioning scheme like PartitionFinder.</li><li><strong>Big Data Analysis</strong>: Supporting huge datasets with thousands of sequences or millions of alignment sites via <a href=""http://www.iqtree.org/doc/Command-Reference#checkpointing-to-resume-stopped-run"">checkpointing</a>, safe numerical and low memory mode. <a href=""http://www.iqtree.org/doc/Tutorial#utilizing-multi-core-cpus"">Multicore CPUs</a> and <a href=""http://www.iqtree.org/doc/Compilation-Guide#compiling-mpi-version"">parallel MPI system</a> are utilized to speedup analysis.</li><li><strong>Phylogenetic testing</strong>: Several fast branch tests like SH-aLRT and aBayes test (<a href=""https://doi.org/10.1093/sysbio/syr041"">Anisimova et al., 2011</a>) and tree topology tests like the approximately unbiased (AU) test (<a href=""https://doi.org/10.1080/10635150290069913"">Shimodaira, 2002</a>).</li></ul><p>The strength of IQ-TREE is the availability of a wide variety of phylogenetic models:</p><ul><li><strong>Common models</strong>: All <a href=""http://www.iqtree.org/doc/Substitution-Models"">common substitution models</a> for DNA, protein, codon, binary and morphological data with <a href=""http://www.iqtree.org/doc/Substitution-Models#rate-heterogeneity-across-sites"">rate heterogeneity among sites</a> and <a href=""http://www.iqtree.org/doc/Substitution-Models#ascertainment-bias-correction"">ascertainment bias correction</a> for e.g. SNP data.</li><li><strong><a href=""http://www.iqtree.org/doc/Complex-Models#partition-models"">Partition models</a></strong>: Allowing individual models for different genomic loci (e.g. genes or codon positions), mixed data types, mixed rate heterogeneity types, linked or unlinked branch lengths between partitions.</li><li><strong>Mixture models</strong>: <a href=""http://www.iqtree.org/doc/Complex-Models#mixture-models"">fully customizable mixture models</a> and <a href=""http://www.iqtree.org/doc/Substitution-Models#protein-mixture-models"">empirical protein mixture models</a> and.</li><li><strong>Polymorphism-aware models</strong>: Accounting for <em>incomplete lineage sorting</em> to infer species tree from genome-wide population data (<a href=""https://doi.org/10.1016/j.jtbi.2016.07.042"">Schrempf et al., 2016</a>).</li></ul></classify1>",Key features,64.0,64.0,"Efficient search algorithm: Fast and effective stochastic algorithm to reconstruct phylogenetic trees by maximum likelihood. IQ-TREE compares favorably to RAxML and PhyML in terms of likelihood while requiring similar amount of computing time (Nguyen et al., 2015).Ultrafast bootstrap: An ultrafast bootstrap approximation (UFBoot) to assess branch supports. UFBoot is 10 to 40 times faster than RAxML rapid bootstrap and obtains less biased support values (Minh et al., 2013; Hoang et al., 2018).Ultrafast model selection: An ultrafast and automatic model selection (ModelFinder) which is 10 to 100 times faster than jModelTest and ProtTest. ModelFinder also finds best-fit partitioning scheme like PartitionFinder.Big Data Analysis: Supporting huge datasets with thousands of sequences or millions of alignment sites via checkpointing, safe numerical and low memory mode. Multicore CPUs and parallel MPI system are utilized to speedup analysis.Phylogenetic testing: Several fast branch tests like SH-aLRT and aBayes test (Anisimova et al., 2011) and tree topology tests like the approximately unbiased (AU) test (Shimodaira, 2002)."
"<classify1 id=""2""><h2 id=""free-web-server"">Free web server</h2><div class=""hline""></div><p>For a quick start you can also try the IQ-TREE web server, which performs online computation using a dedicated computing cluster. It is very easy to use with as few as just 3 clicks! Try it out at</p><p><a href=""http://iqtree.cibiv.univie.ac.at/"">http://iqtree.cibiv.univie.ac.at</a></p></classify1>",Free web server,65.0,65.0,"For a quick start you can also try the IQ-TREE web server, which performs online computation using a dedicated computing cluster. It is very easy to use with as few as just 3 clicks! Try it out at"
"<classify1 id=""3""><h2 id=""user-support"">User support</h2><div class=""hline""></div><p>Please refer to the <a href=""http://www.iqtree.org/doc/"">user documentation</a> and <a href=""http://www.iqtree.org/doc/Frequently-Asked-Questions"">frequently asked questions</a>. If you have further questions, feedback, feature requests, and bug reports, please sign up the following Google group (if not done yet) and post a topic to the</p><p><a href=""https://groups.google.com/d/forum/iqtree"">https://groups.google.com/d/forum/iqtree</a></p><p><em>The average response time is two working days.</em></p></classify1>",User support,66.0,66.0,"Please refer to the user documentation and frequently asked questions. If you have further questions, feedback, feature requests, and bug reports, please sign up the following Google group (if not done yet) and post a topic to the"
"<classify1 id=""4""><h2 id=""documentation"">Documentation</h2><div class=""hline""></div><p>IQ-TREE has an extensive documentation with several tutorials and manual:</p><ul><li><a href=""http://www.iqtree.org/doc/Quickstart"">Getting started guide</a>: recommended for users who just downloaded IQ-TREE.</li><li><a href=""http://www.iqtree.org/doc/Web-Server-Tutorial"">Web Server Tutorial</a>: A quick starting guide for the IQ-TREE Web Server.</li><li><a href=""http://www.iqtree.org/doc/Tutorial"">Beginner’s tutorial</a>: recommended for users starting to use IQ-TREE.</li><li><a href=""http://www.iqtree.org/doc/Advanced-Tutorial"">Advanced tutorial</a>: recommended for more experienced users who want to explore more features of IQ-TREE.</li><li><a href=""http://www.iqtree.org/doc/Command-Reference"">Command Reference</a>: Comprehensive documentation of command-line options available in IQ-TREE.</li><li><a href=""http://www.iqtree.org/doc/Substitution-Models"">Substitution Models</a>: All common substitution models and usages.</li><li><a href=""http://www.iqtree.org/doc/Complex-Models"">Complex Models</a>: Complex models such as partition and mixture models.</li><li><a href=""http://www.iqtree.org/doc/Polymorphism-Aware-Models"">Polymorphism Aware Models</a>: Polymorphism-aware phylogenetic Models (PoMo) related documentation.</li><li><a href=""http://www.iqtree.org/doc/Compilation-Guide"">Compilation guide</a>: for advanced users who wants to compile IQ-TREE from source code.</li><li><a href=""http://www.iqtree.org/doc/Frequently-Asked-Questions"">Frequently asked questions (FAQ)</a>: recommended to have a look before you post a question in the <a href=""https://groups.google.com/d/forum/iqtree"">IQ-TREE group</a>.</li></ul></classify1>",Documentation,67.0,67.0,IQ-TREE has an extensive documentation with several tutorials and manual:
"<classify1 id=""5""><h2 id=""how-to-cite-iq-tree"">How to cite IQ-TREE?</h2><div class=""hline""></div><blockquote><p><strong>To maintain IQ-TREE, support users and secure fundings, it is important for us that you cite the following papers, whenever the corresponding features were applied for your analysis.</strong></p><ul><li><p>Example 1: <em>We obtained branch supports with the ultrafast bootstrap (Hoang et al., 2018) implemented in the IQ-TREE software (Nguyen et al., 2015).</em></p></li><li><p>Example 2: <em>We inferred the maximum-likelihood tree using the edge-linked partition model in IQ-TREE (Chernomor et al., 2016; Nguyen et al., 2015).</em></p></li></ul></blockquote><p>If you performed the tests of symmetry, please cite:</p><ul><li><strong>S. Naser-Khdour, B.Q. Minh, W. Zhang, E.A. Stone, R. Lanfear</strong> (2019) The prevalence and pmpact of model violations in phylogenetic analysis, <em>Genome Biol. Evol.</em>, in press. <a href=""https://doi.org/10.1093/gbe/evz193"">https://doi.org/10.1093/gbe/evz193</a></li></ul><p>If you used the polymorphism-aware models please cite:</p><ul><li><strong>D. Schrempf, B.Q. Minh, A. von Haeseler, and C. Kosiol</strong> (2019) Polymorphism-aware species trees with advanced mutation models, bootstrap, and rate heterogeneity. <em>Mol. Biol. Evol.</em>, 36:1294-1301. <a href=""https://doi.org/10.1093/molbev/msz043"">https://doi.org/10.1093/molbev/msz043</a></li></ul><p>If you used the heterotachy model (GHOST) please cite:</p><ul><li><strong>S.M. Crotty, B.Q. Minh, N.G. Bean, B.R. Holland, J. Tuke, L.S. Jermiin, A. von Haeseler</strong> (2019) GHOST: Recovering historical signal from heterotachously-evolved sequence alignments. <em>Syst. Biol.</em>, in press. <a href=""https://doi.org/10.1093/sysbio/syz051"">https://doi.org/10.1093/sysbio/syz051</a></li></ul><p>If you performed the ultrafast bootstrap (UFBoot) please cite:</p><ul><li><strong>D.T. Hoang, O. Chernomor, A. von Haeseler, B.Q. Minh, and L.S. Vinh</strong> (2018) UFBoot2: Improving the ultrafast bootstrap approximation. <em>Mol. Biol. Evol.</em>, 35:518–522. <a href=""https://doi.org/10.1093/molbev/msx281"">https://doi.org/10.1093/molbev/msx281</a></li></ul><p>If you used posterior mean site frequency model please cite:</p><ul><li><strong>H.C. Wang, B.Q. Minh, S. Susko and A.J. Roger</strong> (2018) Modeling site heterogeneity with posterior mean site frequency profiles accelerates accurate phylogenomic estimation. <em>Syst. Biol.</em>, 67:216-235. <a href=""https://doi.org/10.1093/sysbio/syx068"">https://doi.org/10.1093/sysbio/syx068</a></li></ul><p>If you used ModelFinder please cite:</p><ul><li><strong>S. Kalyaanamoorthy, B.Q. Minh, T.K.F. Wong, A. von Haeseler, and L.S. Jermiin</strong> (2017) ModelFinder: Fast Model Selection for Accurate Phylogenetic Estimates, <em>Nature Methods</em>, 14:587–589. <a href=""https://doi.org/10.1038/nmeth.4285"">https://doi.org/10.1038/nmeth.4285</a></li></ul><p>If you performed tree reconstruction please cite:</p><ul><li><strong>L.-T. Nguyen, H.A. Schmidt, A. von Haeseler, and B.Q. Minh</strong> (2015) IQ-TREE: A fast and effective stochastic algorithm for estimating maximum likelihood phylogenies. <em>Mol. Biol. Evol.</em>, 32:268-274. <a href=""https://doi.org/10.1093/molbev/msu300"">https://doi.org/10.1093/molbev/msu300</a></li></ul><p>If you used partition models e.g., for phylogenomic analysis please cite:</p><ul><li><strong>O. Chernomor, A. von Haeseler, and B.Q. Minh</strong> (2016) Terrace aware data structure for phylogenomic inference from supermatrices. <em>Syst. Biol.</em>, 65:997-1008. <a href=""https://doi.org/10.1093/sysbio/syw037"">https://doi.org/10.1093/sysbio/syw037</a></li></ul><p>If you used the <a href=""http://iqtree.cibiv.univie.ac.at/"">IQ-TREE web server</a> please cite:</p><ul><li><strong>J. Trifinopoulos, L.-T. Nguyen, A. von Haeseler, and B.Q. Minh</strong> (2016) W-IQ-TREE: a fast online phylogenetic tool for maximum likelihood analysis. <em>Nucleic Acids Res.</em>, 44 (W1):W232-W235. <a href=""https://doi.org/10.1093/nar/gkw256"">https://doi.org/10.1093/nar/gkw256</a></li></ul></classify1>",How to cite IQ-TREE?,68.0,68.0,"To maintain IQ-TREE, support users and secure fundings, it is important for us that you cite the following papers, whenever the corresponding features were applied for your analysis.Example 1: We obtained branch supports with the ultrafast bootstrap (Hoang et al., 2018) implemented in the IQ-TREE software (Nguyen et al., 2015).Example 2: We inferred the maximum-likelihood tree using the edge-linked partition model in IQ-TREE (Chernomor et al., 2016; Nguyen et al., 2015)."
"<classify1 id=""6""><h2 id=""development-team"">Development team</h2><div class=""hline""></div><p>IQ-TREE is actively developed by:</p><p><strong>Bui Quang Minh</strong>, <em>Team leader</em>, Designs and implements software core, tree search, ultrafast bootstrap, model selection.</p><p><strong>Robert Lanfear</strong>, <em>Co-leader</em>, Model selection.</p><p><strong>Olga Chernomor</strong>, <em>Developer</em>, Implements partition models.</p><p><strong>Heiko A. Schmidt</strong>, <em>Developer</em>, Integrates TREE-PUZZLE features.</p><p><strong>Dominik Schrempf</strong>, <em>Developer</em>, Implements polymorphism-aware models (PoMo).</p><p><strong>Michael Woodhams</strong>, <em>Developer</em>, Implements Lie Markov models.</p><p><strong>Diep Thi Hoang</strong>, <em>Developer</em>, Improves ultrafast bootstrap.</p><p><strong>Arndt von Haeseler</strong>, <em>Advisor</em>.</p><p>Past members:</p><p><strong>Lam Tung Nguyen</strong>, <em>Developer</em>, Implemented tree search algorithm.</p><p><strong>Jana Trifinopoulos</strong>, <em>Developer</em>, Implemented web service.</p></classify1>",Development team,69.0,69.0,IQ-TREE is actively developed by:
"<classify1 id=""7""><h2 id=""credits-and-acknowledgements"">Credits and acknowledgements</h2><div class=""hline""></div><p>Some parts of the code were taken from the following packages/libraries: <a href=""http://www.libpll.org/"">Phylogenetic likelihood library</a>, <a href=""http://www.tree-puzzle.de/"">TREE-PUZZLE</a>, <a href=""https://doi.org/10.1093/oxfordjournals.molbev.a025808"">BIONJ</a>, <a href=""https://doi.org/10.1093/bioinformatics/btg319"">Nexus Class Libary</a>, <a href=""http://eigen.tuxfamily.org/"">Eigen library</a>, <a href=""http://www.sprng.org/"">SPRNG library</a>, <a href=""http://www.zlib.net/"">Zlib library</a>, gzstream library, <a href=""http://www.agner.org/optimize/"">vectorclass library</a>, <a href=""https://www.gnu.org/software/gsl/"">GNU scientific library</a>.</p><p>IQ-TREE was funded by the <a href=""http://www.fwf.ac.at/"">Austrian Science Fund</a> (grant no. I760-B17 from 2012-2015 and I 2508-B29 from 2016-2017), the <a href=""https://www.univie.ac.at/"">University of Vienna</a> (Initiativkolleg I059-N from 2012-2015), the <a href=""https://www.anu.edu.au/"">Australian National University</a> (2018-onwards), <a href=""https://chanzuckerberg.com/"">Chan-Zuckerberg Initiative</a> (2020).</p><div class=""spacing""></div></classify1>",Credits and acknowledgements,70.0,70.0,"Some parts of the code were taken from the following packages/libraries: Phylogenetic likelihood library, TREE-PUZZLE, BIONJ, Nexus Class Libary, Eigen library, SPRNG library, Zlib library, gzstream library, vectorclass library, GNU scientific library."
"<classify1 id=""0""><h2 id=""inferring-time-tree-with-tip-dates"">Inferring time tree with tip dates</h2><p>This is a common scenario e.g. in virus datasets where you have sampling time for many sequences. You need first to prepare a <em>date file</em>, which comprises several lines, each with a taxon name (from your sequence alignment) and its date separated by spaces, tabs or blanks. Note that it is not required to have dates for all tips. For example, this date file is part of the new corona virus dataset:</p><pre><code>hCoV-19/Wuhan-Hu-1         2019-12-31
hCoV-19/China/WF0028       2020-02
hCoV-19/USA/WA-S88         2020-03-01
hCoV-19/USA/CA-CDPH-UC1	   2020
hCoV-19/Italy/SPL1         2020-01-29
hCoV-19/Spain/Valencia5	   2020-02-27
hCoV-19/Australia/QLD01	   2020-01-28
hCoV-19/Vietnam/CM295      2020-03-06
hCoV-19/bat/Yunnan         2013-07-24
hCoV-19/pangolin/Guangdong 2019-02-01:2019-12-31
</code></pre><p>The date information here can be uncertain. For example, <code>hCoV-19/China/WF0028</code> was sampled in Feb 2020, <code>hCoV-19/USA/CA-CDPH-UC1</code> was sampled in 2020, and <code>hCoV-19/pangolin/Guangdong</code> was sample between 1st Feb 2019 and 31st Dec 2019. For such data range you can use “NA” to mean that the lower or upper bound is missing, e.g.:</p><pre><code>TaxonA  2018-02-01:NA
TaxonB  NA:2018-03-31
</code></pre><p>which means that <code>TaxonA</code> was sampled after 1st Feb 2018 and TaxonB was sampled before 31st Mar 2018.</p><p>Now run IQ-TREE with:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE
</code></pre><p>where <code>ALN_FILE</code> is the sequence alignment and <code>DATE_FILE</code> is the date file. This single command line will perform three steps: (1) find the best-fit model using ModelFinder, (2) find the maximum likelihood (ML) tree with branch lengths in number of substitutions per site, and (3) rescale the branch lengths of the ML tree to build a time tree with dated ancestral node. As output IQ-TREE will additional print three files:</p><ul><li><code>ALN_FILE.timetree.lsd</code>: The report of LSD.</li><li><code>ALN_FILE.timetree.nex</code>: Time tree file in NEXUS format, that can be viewed nicely in FigTree (Click on “Node Labels” on the left tab and choose “Display” as “date” in FigTree, see figure below).</li><li><code>ALN_FILE.timetree.nwk</code>: Time tree file in NEWICK format.</li></ul><p><img alt=""Node dates in FigTree"" src=""./Phylogenetic Dating_files/dating-figtree.png""/></p><p>This command will automatically detect the best root position (according to LSD criterion). However, if the root is incorrectly inferred, it may produce wrong dates. Therefore, it is advisable to provide outgroup taxa if possible. In this example, we have this information, so you can use <code>-o</code> option:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE -o ""hCoV-19/bat/Yunnan,hCoV-19/pangolin/Guangdong""
</code></pre><p>to instruct IQ-TREE that the root is on the branch separating <code>bat</code> and <code>pangolin</code> sequences from the rest.</p><p>Alternatively you can also append the dates into the sequence names of the alignment file using the <code>|</code> separator, such as (assuming a FASTA file here):</p><pre><code>&gt;hCoV-19/Wuhan-Hu-1|2019-12-31
......
&gt;hCoV-19/China/WF0028|2020-02
......
&gt;hCoV-19/USA/WA-S88|2020-03-01
......
&gt;hCoV-19/USA/CA-CDPH-UC1|2020
......
&gt;hCoV-19/Italy/SPL1|2020-01-29
......
&gt;hCoV-19/Spain/Valencia5|2020-02-27
......
&gt;hCoV-19/Australia/QLD01|2020-01-28
......
&gt;hCoV-19/Vietnam/CM295|2020-03-06
......
&gt;hCoV-19/bat/Yunnan|2013-07-24
......
&gt;hCoV-19/pangolin/Guangdong|2019
......
</code></pre><p>Then run IQ-TREE:</p><pre><code>iqtree -s ALN_FILE --date TAXNAME -o ""hCoV-19/bat/Yunnan,hCoV-19/pangolin/Guangdong""
</code></pre><p>The special keyword <code>TAXNAME</code> for the <code>--date</code> option instructs IQ-TREE to automatically extract the dates from the taxon names.</p></classify1>",Inferring time tree with tip dates,71.0,71.0,"hCoV-19/Wuhan-Hu-1         2019-12-31
hCoV-19/China/WF0028       2020-02
hCoV-19/USA/WA-S88         2020-03-01
hCoV-19/USA/CA-CDPH-UC1	   2020
hCoV-19/Italy/SPL1         2020-01-29
hCoV-19/Spain/Valencia5	   2020-02-27
hCoV-19/Australia/QLD01	   2020-01-28
hCoV-19/Vietnam/CM295      2020-03-06
hCoV-19/bat/Yunnan         2013-07-24
hCoV-19/pangolin/Guangdong 2019-02-01:2019-12-31
"
"<classify1 id=""1""><h2 id=""calibrating-tree-using-ancestral-dates"">Calibrating tree using ancestral dates</h2><p>Another scenario is that we have sequences from present day and want to calibrate the dates of the ancestral nodes. This will only work if you have fossil date record of at least one ancestral node in the tree. Then you again need to prepare a date file which looks like:</p><pre><code>taxon1,taxon2	      -50
taxon3,taxon4,taxon5  -100
taxon6                -10
</code></pre><p>which, for example, mean that the most recent common ancestor (MRCA) of <code>taxon1</code> and <code>taxon2</code> was 50 mya (million year ago) and the MRCA of <code>taxon3</code>, <code>taxon4</code>, <code>taxon5</code> was 100 mya. Note that <strong>no empty space</strong> should be added to the comma-separated list of taxa, as empty space is used as a separator between taxon list and dates.</p><p>Now run IQ-TREE:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE --date-tip 0
</code></pre><p>This means that except for <code>taxon6</code>, all other taxa have the date of 0 for presence.</p><p>If you know the root date, then you can set it via <code>--date-root</code> option.</p></classify1>",Calibrating tree using ancestral dates,72.0,72.0,"taxon1,taxon2	      -50
taxon3,taxon4,taxon5  -100
taxon6                -10
"
"<classify1 id=""2""><h2 id=""dating-an-existing-tree"">Dating an existing tree</h2><p>If you already have a tree, you can use option <code>-te TREE_FILE</code> to ask IQ-TREE to load and fix this tree topology:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE -te TREE_FILE
</code></pre><p>This will work with the scenarios above, i.e., IQ-TREE will date the user-defined tree instead of the ML tree. To further speed up the process: If you know the model already, you set can it via <code>-m</code> option; or in a partitioned analysis, you can provide a partition file with specified models.</p></classify1>",Dating an existing tree,73.0,73.0,"iqtree -s ALN_FILE --date DATE_FILE -te TREE_FILE
"
"<classify1 id=""3""><h2 id=""obtaining-confidence-intervals"">Obtaining confidence intervals</h2><p>To infer the confidence interval of the estimated dates, use <code>--date-ci</code> option:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE --date-ci 100
</code></pre><p>which will resample branch lengths 100 times to infer the confidence intervals. Note that this is not bootstrap and the method is much faster but unpublished. Roughly speaking, it is based on a mixture of Poisson and lognormal distributions for a relaxed clock model. You can control the standard deviation of the lognormal distribution via <code>--clock-sd</code> option. The default is 0.2. If you set a higher value, the confidence interval will become wider.</p></classify1>",Obtaining confidence intervals,74.0,74.0,"iqtree -s ALN_FILE --date DATE_FILE --date-ci 100
"
"<classify1 id=""4""><h2 id=""excluding-outlier-taxanodes"">Excluding outlier taxa/nodes</h2><p>Long branches may cause biased date estimates. To detect and exclude outlier taxa or nodes prior to dating, use <code>--date-outlier</code> option:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE --date-outlier 3
</code></pre><p>that specifies a z-score threshold to detect outliers. The higher this value is, the more outliers will be removed from the resulting time tree.</p></classify1>",Excluding outlier taxa/nodes,75.0,75.0,"iqtree -s ALN_FILE --date DATE_FILE --date-outlier 3
"
"<classify1 id=""5""><h2 id=""full-list-of-lsd2-options"">Full list of LSD2 options</h2><p>The main options in IQ-TREE provide easy access to the key LSD2 functions. If you would like more control of what LSD2 is doing, you can use the <code>--date-options ""...""</code> command to pass any valid options to LSD2. For example, to control the way that LSD2 treats outliers, you can do this:</p><pre><code>iqtree -s ALN_FILE --date DATE_FILE --date-options ""-e 2""
</code></pre><p>A full list of the options for LSD2 can be obtained by downloading LSD2 and running <code>lsd2 -h</code>, the output of that command is reproduced here for convenience:</p><pre><code>LSD: LEAST-SQUARES METHODS TO ESTIMATE RATES AND DATES - v.1.8

DESCRIPTION
	This program estimates the rate and the dates of the input phylogenies given some temporal constraints.
	It minimizes the square errors of the branch lengths under normal distribution model.

SYNOPSIS
	./lsd [-i inputFile] [-d inputDateFile] [-o outputFile] [-s sequenceLength] [-g outgroupFile] [-f nbSamplings] 
OPTIONS
	-a rootDate
	   To specify the root date if there's any. If the root date is not a number, but a string (ex: 2020-01-10, or b(2019,2020)) then it should
	   be put between the quotes.
	-b varianceParameter
	   The parameter (between 0 and 1) to compute the variances in option -v. It is the pseudo positive constant to add to the branch lengths
	   when calculating variances, to adjust the dependency of variances to branch lengths. By default b is the maximum between median branch length
	   and 10/seqlength; but it should be adjusted  based on how/whether the input tree is relaxed or strict. The smaller it is the more variances
	   would be linear to branch lengths, which is relevant for strict clock. The bigger it is the less effect of branch lengths on variances, 
	   which might be better for relaxed clock.
	-d inputDateFile
	   This options is used to read the name of the input date file which contains temporal constraints of internal nodes
	   or tips. An internal node can be defined either by its label (given in the input tree) or by a subset of tips that have it as 
	   the most recent common ancestor (mrca). A date could be a real or a string or format year-month-day.
	   The first line of this file is the number of temporal constraints. A temporal constraint can be fixed date, or a 
	   lower bound l(value), or an upper bound u(value), or an interval b(v1,v2)
	   For example, if the input tree has 4 taxa a,b,c,d, and an internal node named n, then following is a possible date file:
	    6
	    a l(2003.12)
	    b u(2007.07)
	    c 2005
	    d b(2001.2,2007.11)
	    mrca(a,b,c,d) b(2000,2001)
	    n l(2004.3)
	   If this option is omitted, and option -a, -z are also omitted, the program will estimate relative dates by giving T[root]=0 and T[tips]=1.
	-D outDateFormat
	    Specify output date format: 1 for real, 2 for year-month-day. By default the program will guess the format of input dates and uses it for
	    output dates.
	-e ZscoreOutlier
	   This option is used to estimate and exclude outlier nodes before dating process.
	   LSD2 normalize the branch residus and decide a node is outlier if its related residus is great than the ZscoreOutlier.
	   A normal value of ZscoreOutliercould be 3, but you can adjust it bigger/smaller depending if you want to have
	   less/more outliers. Note that for now, some functionalities could not be combined with outliers estimation, for example 
	   estimating multiple rates, imprecise date constraints.
	-f samplingNumberCI
	   This option calculates the confidence intervals of the estimated rate and dates. The branch lengths of the esimated
	   tree are sampled samplingNumberCI times to generate a set of simulated trees. To generate simulated lengths
	   for each branch, we use a Poisson distribution whose mean equals to the estimated one multiplied by the sequence length, which is 
	   1000 by default if nothing was specified via option -s. Long sequence length tends to give small confidence intervals. To avoid 
	   over-estimate the confidence intervals in the case of very long sequence length but not necessarily strict molecular clock, you 
	   could use a smaller sequence length than the actual ones. Confidence intervals are written in the nexus tree with label CI_height,
	   and can be visualzed with Figtree under Node bar feature.
	-g outgroupFile
	   If your data contain outgroups, then specify the name of the outgroup file here. The program will use the outgroups to root the trees.
	   If you use this combined with options -G, then the outgroups will be removed. The format of this file should be:
	        n
	        OUTGROUP1
	        OUTGROUP2
	        ...
	        OUTGROUPn
	-F 
	   By default without this option, we impose the constraints that the date of every node is equal or smaller then the
	   dates of its descendants, so the running time is quasi-linear. Using this option we ignore this temporal constraints, and
	   the the running time becomes linear, much faster.
	-h help
	   Print this message.
	-i inputTreesFile
	   The name of the input trees file. It contains tree(s) in newick format, each tree on one line. Note that the taxa sets of all
	   trees must be the same.
	-j
	   Verbose mode for output messages.
	-G
	   Use this option to remove the outgroups (given in option -g) in the estimated tree. If this option is not used, the outgroups 
	   will be kept and the root position in estimated on the branch defined by the outgroups.
	-l nullBlen
	   A branch in the input tree is considered informative if its length is greater this value. By default it is 0.5/seq_length. Only 
	   informative branches are forced to be bigger than a minimum branch length (see option -u for more information about this).
	-m samplingNumberOutlier
	   The number of dated nodes to be sampled when detecting outlier nodes. This should be smaller than the number of dated nodes,
	   and is 10 by default.
	-n datasetNumber
	   The number of trees that you want to read and analyse.
	-o outputFile
	   The base name of the output files to write the results and the time-scale trees.
	-p partitionFile
	   The file that defines the partition of branches into multiple subsets in the case that you know each subset has a different rate.
	   In the partition file, each line contains the name of the group, the prior proportion of the group rate compared to the main rate
	   (selecting an appropriate value for this helps to converge faster), and a list of subtrees whose branches are supposed to have the 
	   same substitution rate. All branches that are not assigned to any subtree form a group having another rate.
	   A subtree is defined between {}: its first node corresponds to the root of the subtree, and the following nodes (if there any) 
	   correspond to the tips of the subtree. If the first node is a tip label then it takes the mrca of all tips as the root of the subtree.
	   If the tips of the subtree are not defined (so there's only the defined root), then by 
	   default this subtree is extended down to the tips of the full tree. For example the input tree is 
	   ((A:0.12,D:0.12)n1:0.3,((B:0.3,C:0.5)n2:0.4,(E:0.5,(F:0.2,G:0.3)n3:0.33)n4:0.22)n5:0.2)root;
	   and you have the following partition file:
	         group1 1 {n1} {n5 n4}
	         group2 1 {n3}
	   then there are 3 rates: the first one includes the branches (n1,A), (n1,D), (n5,n4), (n5,n2), (n2,B), (n2,C); the second one 
	   includes the branches (n3,F), (n3,G), and the last one includes all the remaining branches. If the internal nodes don't have labels,
	   then they can be defined by mrca of at least two tips, for example n1 is mrca(A,D)
	-q standardDeviationRelaxedClock
	   This value is involved in calculating confidence intervals to simulate a lognormal relaxed clock. We multiply the simulated branch lengths
	   with a lognormal distribution with mean 1, and standard deviation q. By default q is 0.2. The bigger q is, the more your tree is relaxed
	   and give you bigger confidence intervals.
	-r rootingMethod
	   This option is used to specify the rooting method to estimate the position of the root for unrooted trees, or
	   re-estimate the root for rooted trees. The principle is to search for the position of the root that minimizes
	   the objective function.
	   Use -r l if your tree is rooted, and you want to re-estimate the root locally around the given root.
	   Use -r a if you want to estimate the root on all branches (ignoring the given root if the tree is rooted).
	       In this case, if the constrained mode is chosen (option -c), method ""a"" first estimates the root without using the constraints.
	       After that, it uses the constrained mode to improve locally the position of the root around this pre-estimated root.
	   Use -r as if you want to estimate to root using constrained mode on all branches.
	   Use -r k if you want to re-estimate the root position on the same branche of the given root.
	       If combined with option -g, the root will be estimated on the branche defined by the outgroups.
	-R round_time
	   This value is used to round the minimum branch length of the time scaled tree. The purpose of this is to make the minimum branch length
	   a meaningful time unit, such as day, week, year ... By default this value is 365, so if the input dates are year, the minimum branch
	   length is rounded to day. The rounding formula is round(R*minblen)/R.
	-s sequenceLength
	   This option is used to specify the sequence length when estimating confidence intervals (option -f). It is used to generate 
	   integer branch lengths (number of substitutions) by multiplying this with the estimated branch lengths. By default it is 1000.
	-S minSupport
	   Together with collapsing internal short branches (see option -l), users can also collapse internal branches having weak support values (if
	   provided in the input tree) by using this option. The program will collapse all internal branches having support &lt;= the specifed value.
	-t rateLowerBound
	   This option corresponds to the lower bound for the estimating rate. It is 1e-10 by default.
	-u minBlen
	   By default without this option, lsd2 forces every branch of the time scaled tree to be greater than 1/(seq_length*rate) where rate is
	   an pre-estimated median rate. This value is rounded to the number of days or weeks or years, depending on the rounding parameter -R.
	   By using option -u, the program will not estimate the minimum branch length but use the specified value instead.
	-U minExBlen
	   Similar to option -u but applies for external branches if specified. If it's not specified then the minimum branch length of external
	   branches is set the same as the one of internal branch.
	-v variance
	   Use this option to specify the way you want to apply variances for the branch lengths. Variances are used to recompense big errors on
	   long estimated branch lengths. The variance of the branch Bi is Vi = (Bi+b) where b is specified by option -b.
	   If variance=0, then we don't use variance. If variance=1, then LSD uses the input branch lengths to calculate variances.
	   If variance=2, then LSD runs twice where the second time it calculates the variances based on the estimated branch
	   lengths of the first run. By default variance=1.
	-V 
	   Get the actual version.
	-w givenRte
	   This option is used to specify the name of the file containing the substitution rates.
	   In this case, the program will use the given rates to estimate the dates of the nodes.
	   This file should have the following format
	        RATE1
	        RATE2
	        ...
	  where RATEi is the rate of the tree i in the inputTreesFile.
	-z tipsDate
	   To specify the tips date if they are all equal. If the tips date is not a number, but a string (ex: 2020-01-10, or b(2019,2020))
	   then it should be put between the quotes.
</code></pre><div class=""spacing""></div></classify1>",Full list of LSD2 options,76.0,76.0,"iqtree -s ALN_FILE --date DATE_FILE --date-options ""-e 2""
"
"<classify1 id=""0""><h2 id=""counts-files"">Counts files</h2><div class=""hline""></div><p>The input of PoMo is allele frequency data. Especially, when populations have many individuals it is preferable to count the number of bases at each position compared to providing data for each chromosome in a FASTA file. Thereby file size is decreased and parsed faster.</p><p>Counts files contain:</p><ul><li><p>One headerline that specifies the file as counts file and states the number of populations (leaves on the tree) as well as the number of sites (separated by white space).</p></li><li><p>A second headerline with white space separated headings: CRHOM (chromosome), POS (position) and sequence names.</p></li><li><p>Many lines with counts of A, C, G and T bases and their respective positions.</p></li></ul><p>Comments:</p><ul><li>Lines before the first headerline starting with # are treated as comments.</li></ul><p>Example:</p><pre><code>COUNTSFILE  NPOP 5   NSITES N
CHROM  POS  Sheep    BlackSheep  RedSheep  Wolf     RedWolf
1      1    0,0,1,0  0,0,1,0     0,0,1,0   0,0,5,0  0,0,0,1
1      2    0,0,0,1  0,0,0,1     0,0,0,1   0,0,0,5  0,0,0,1
.
.
.
9      8373 0,0,0,1  1,0,0,0     0,1,0,0   0,1,4,0  0,0,1,0
.
.
.
Y      9999 0,0,0,1  0,1,0,0     0,1,0,0   0,5,0,0  0,0,1,0
</code></pre><p>The download also includes an example counts file called <a href=""https://github.com/Cibiv/IQ-TREE/blob/PoMo/example/example.cf""><code>example.cf</code></a>. This file is a subset of the <a href=""https://github.com/pomo-dev/data/tree/master/SystBiol2015"">great ape data</a> that has been analyzed in one of our publications. It includes twelve great ape population with one to 23 inividuals each (two to 56 chromosomes).</p><h3 id=""conversion-scripts"">Conversion scripts</h3><p>If you do not want to create counts files with your own scripts, you can use the python script that we provide. For detailed instructions, please refer to the <a href=""https://github.com/pomo-dev/cflib"">GitHub repository of the counts file library <code>cflib</code></a>.</p></classify1>",Counts files,77.0,77.0,"The input of PoMo is allele frequency data. Especially, when populations have many individuals it is preferable to count the number of bases at each position compared to providing data for each chromosome in a FASTA file. Thereby file size is decreased and parsed faster."
"<classify1 id=""1""><h2 id=""first-running-example"">First running example</h2><div class=""hline""></div><p>You can now start to reconstruct a maximum-likelihood tree from this alignment by entering (assuming that <code>example.cf</code> is in the same folder):</p><pre><code>iqtree -s example.cf -m HKY+P
</code></pre><p>or, e.g.,</p><pre><code>iqtree -nt 4 -s example.cf -m HKY+P
</code></pre><p>if you use the multicore (OMP) version. <code>-s</code> specifies of the alignment file and <code>-m</code> the model (HKY substitution model with polymorphisms; PoMo), similar to the standard IQ-TREE usage. At the end of the run IQ-TREE writes the same output files as in the standard version (see <a href=""http://www.iqtree.org/doc/Tutorial"">tutorial</a>).</p><ul><li><code>example.cf.iqtree</code>: the main report file that is self-readable. You should look at this file to see the computational results. It also contains a textual representation of the final tree.</li><li><code>example.cf.treefile</code>: the ML tree in NEWICK format, which can be visualized by any supported tree viewer programs like FigTree or iTOL.</li><li><code>example.cf.log</code>: log file of the entire run (also printed on the screen). To report bugs, please send this log file and the original alignment file to the authors.</li></ul><p>The default prefix of all output files is the alignment file name. However, you can always change the prefix using the <code>-pre</code> option, e.g.:</p><pre><code>iqtree -s example.cf -pre myprefix
</code></pre><p>This prevents output files to be overwritten when you perform multiple analyses on the same alignment within the same folder.</p></classify1>",First running example,78.0,78.0,You can now start to reconstruct a maximum-likelihood tree from this alignment by entering (assuming that example.cf is in the same folder):
"<classify1 id=""2""><h2 id=""substitution-models"">Substitution models</h2><div class=""hline""></div><p>Different DNA substitution models can be selected with the <code>-m</code> option. E.g., to select the GTR model, run IQ-TREE with:</p><pre><code>iqtree -s example.cf -m GTR+P
</code></pre><blockquote class=""tip""><p><strong>TIP</strong>: For a quick overview of all available models in IQ-TREE, run the command <code>iqtree -h</code> and scroll to the heading <code>POLYMORPHISM AWARE MODELS (PoMo)</code>.</p></blockquote></classify1>",Substitution models,79.0,79.0,"Different DNA substitution models can be selected with the -m option. E.g., to select the GTR model, run IQ-TREE with:"
"<classify1 id=""3""><h2 id=""virtual-population-size"">Virtual population size</h2><div class=""hline""></div><p>PoMo describes the evolution of populations along a phylogeny by means of a virtual population of constant size <code>N</code>, which defaults to nine (for details, see <a href=""http://dx.doi.org/10.1016/j.jtbi.2016.07.042"">Schrempf et al., 2016</a>). This is a good and stable default value. If only very few chromosomes have been sequenced per population (e.g., two to four), <code>N</code> should be lowered to the average number of chromosomes per population. If enough data is available and calculations are not too time consuming, we advise to increase N up to a maximum of 19. You can choose odd values from three to 19 as well as 2 and 10. E.g., to set N to 19:</p><pre><code>iqtree -s example.cf -m HKY+P+N19
</code></pre></classify1>",Virtual population size,80.0,80.0,"PoMo describes the evolution of populations along a phylogeny by means of a virtual population of constant size N, which defaults to nine (for details, see Schrempf et al., 2016). This is a good and stable default value. If only very few chromosomes have been sequenced per population (e.g., two to four), N should be lowered to the average number of chromosomes per population. If enough data is available and calculations are not too time consuming, we advise to increase N up to a maximum of 19. You can choose odd values from three to 19 as well as 2 and 10. E.g., to set N to 19:"
"<classify1 id=""4""><h2 id=""level-of-polymorphism"">Level of polymorphism</h2><div class=""hline""></div><p>As of version <code>1.6</code>, IQ-TREE with PoMo also allows fixation of the level of heterozygosity, which is also called Watterson’s theta or <code>4Nu</code>. When analyzing population data, the amount of polymorphism is inferred during maximization of the likelihood. However, in some situations it may be useful to set the level of polymorphism to the observed value in the data (empirical value):</p><pre><code>iqtree -s example.cf -m HKY+P{EMP}
</code></pre><p>or to set the level of polymorphism by hand, e.g.,:</p><pre><code>iqtree -s example.cf -m HKY+P{0.0025}
</code></pre><p>Together with the ability to set model parameters, the model can be fully specified, e.g.:</p><pre><code>iqtree -s example.cf -m HKY{6.0}+P{0.0025}
</code></pre><p>This sets the transition to transversion ratio to a value of <code>6.0</code> and the level of polymorphism to a value of <code>0.0025</code>. In this case, IQ-TREE only performs a tree search because the model is fully specified.</p></classify1>",Level of polymorphism,81.0,81.0,"As of version 1.6, IQ-TREE with PoMo also allows fixation of the level of heterozygosity, which is also called Watterson’s theta or 4Nu. When analyzing population data, the amount of polymorphism is inferred during maximization of the likelihood. However, in some situations it may be useful to set the level of polymorphism to the observed value in the data (empirical value):"
"<classify1 id=""5""><h2 id=""sampling-method"">Sampling method</h2><div class=""hline""></div><p>For advanced users. PoMo offers different methods to read in the data (<a href=""http://dx.doi.org/10.1016/j.jtbi.2016.07.042"">Schrempf et al., 2016</a>). Briefly, each population and site are treated as follows</p><ol><li><p><em>Weighted binomial</em> (default, <code>+WB</code>): assign the likelihood of each PoMo state to its probability of leading to the observed data, assuming it is <strong>binomially</strong> sampled. Example:</p><pre><code> iqtree -s example.cf -m HKY+P+WB
</code></pre></li><li><p><em>Weighted hypergeometric</em> (<code>+WH</code>): assign the likelihood of each PoMo state to its probability of leading to the observed data, assuming it is <strong>hypergeometrically</strong> sampled. Example:</p><pre><code> iqtree -s example.cf -m HKY+P+WH
</code></pre></li><li><p><em>Sampled</em>: randomly draw N samples with replacement from the given data. The N picked samples constitute a PoMo state which will be assigned a likelihood of 1. All other PoMo states have likelihood 0. Example:</p><pre><code> iqtree -s example.cf -m HKY+P+S
</code></pre></li></ol><p>We expect a slight overestimation of the heterozygosity for <em>weighted binomial</em> sampling. This is because monomorphic (fixed) states can be reached from polymorphic states during the sampling step, while polymorphic states cannot be reached from monomorphic states (sampling does not involve mutation). I.e., only when the level of heterozygosity at the leaves is overestimated, the sampling step leads to the correct amount of heterozygosity observed in the data.</p><p>If you wish to avoid this effect, use <em>weighted hypergeometric</em> sampling. However, we have observed that <em>weighted binomial</em> sampling is more stable.</p></classify1>",Sampling method,82.0,82.0,"For advanced users. PoMo offers different methods to read in the data (Schrempf et al., 2016). Briefly, each population and site are treated as follows"
"<classify1 id=""6""><h2 id=""state-frequency-type"">State frequency type</h2><div class=""hline""></div><p>Similar to standard models, the state frequency type can be selected with <code>+F</code> model string modifiers. The default is to set the state frequencies (i.e., the frequencies of the nucleotides A, C, G and T) to the observed values in the data (empirical value). To estimate the allele frequencies together with the rate parameters during maximization of the likelihood, use:</p><pre><code>iqtree -s example.cf -m GTR+P+FO
</code></pre></classify1>",State frequency type,83.0,83.0,"Similar to standard models, the state frequency type can be selected with +F model string modifiers. The default is to set the state frequencies (i.e., the frequencies of the nucleotides A, C, G and T) to the observed values in the data (empirical value). To estimate the allele frequencies together with the rate parameters during maximization of the likelihood, use:"
"<classify1 id=""7""><h2 id=""rate-heterogeneity"">Rate heterogeneity</h2><div class=""hline""></div><p>Recently, PoMo allows inference with different rate categories. As of version <code>1.6</code>, only discrete Gamma rate heterogeneity is supported. Please be aware, that for biological and mathematical reasons (we cannot simply scale the full transition matrix but have to separate the mutational component from genetic drift), the run time scales linearly with the number of rate categories. In the future, we plan to work on decreasing run time as well as implement more rate heterogeneity types. To use a discrete Gamma model with 4 rate categories, use:</p><pre><code>iqtree -s example.cf -m HKY+P+G4
</code></pre></classify1>",Rate heterogeneity,84.0,84.0,"Recently, PoMo allows inference with different rate categories. As of version 1.6, only discrete Gamma rate heterogeneity is supported. Please be aware, that for biological and mathematical reasons (we cannot simply scale the full transition matrix but have to separate the mutational component from genetic drift), the run time scales linearly with the number of rate categories. In the future, we plan to work on decreasing run time as well as implement more rate heterogeneity types. To use a discrete Gamma model with 4 rate categories, use:"
"<classify1 id=""8""><h2 id=""bootstrap-branch-support"">Bootstrap branch support</h2><div class=""hline""></div><p>Bootstrapping works as expected with PoMo. The standard non-parametric bootstrap is invoked by the <code>-b</code> option, e.g., for 100 replicates:</p><pre><code>iqtree -s example.cf -m HKY+P -b 100
</code></pre><p>To overcome the computational burden required by the non-parametric bootstrap, IQ-TREE introduces an ultra fast bootstrap approximation (UFBoot) that is orders of magnitude faster than the standard procedure and provides relatively unbiased branch support values. To run UFBoot, use the option <code>-bb</code>, e.g., for 1000 replicates:</p><pre><code>iqtree -s example.cf -m HKY+P -bb 1000
</code></pre><p>For a detailed description, please refer to the <a href=""http://www.iqtree.org/doc/Tutorial#assessing-branch-supports-with-ultrafast-bootstrap-approximation"">bootstrap tutorial</a>.</p></classify1>",Bootstrap branch support,85.0,85.0,"Bootstrapping works as expected with PoMo. The standard non-parametric bootstrap is invoked by the -b option, e.g., for 100 replicates:"
"<classify1 id=""9""><h2 id=""interpretation-of-branch-lengths"">Interpretation of branch lengths</h2><div class=""hline""></div><p>PoMo estimates the branch length in number of mutations and frequency shifts (drift) per site. The number of drift events compared to the number of mutations becomes higher if the <a href=""http://www.iqtree.org/doc/Polymorphism-Aware-Models#virtual-population-size"">virtual population size</a> is increased. To get the branch length measured in number of substitutions per site which enables a comparison to the branch length estimated by standard DNA substitution models, it has to be divided by <code>N^2</code>. PoMo also outputs the total tree length measured in number of substitutions per site in <code>example.cf.iqtree</code>. An example of the relevant section:</p><pre><code>NOTE: The branch lengths of PoMo measure mutations and frequency shifts.
To compare PoMo branch lengths to DNA substitution models use the tree length
measured in substitutions per site.

Total tree length (sum of branch lengths)
 - measured in number of mutations and frequency shifts per site: 0.71200751
 - measured in number of substitutions per site (divided by N^2): 0.00879022
Sum of internal branch lengths
- measured in mutations and frequency shifts per site: 0.01767814 (2.48285810% of tree length)
- measured in substitutions per site: 0.01767814 (2.48285810% of tree length)
</code></pre><div class=""spacing""></div></classify1>",Interpretation of branch lengths,86.0,86.0,"PoMo estimates the branch length in number of mutations and frequency shifts (drift) per site. The number of drift events compared to the number of mutations becomes higher if the virtual population size is increased. To get the branch length measured in number of substitutions per site which enables a comparison to the branch length estimated by standard DNA substitution models, it has to be divided by N^2. PoMo also outputs the total tree length measured in number of substitutions per site in example.cf.iqtree. An example of the relevant section:"
"<classify1 id=""0""><h2 id=""inferring-unrooted-tree-with-outgroup"">Inferring unrooted tree with outgroup</h2><p>We first demonstrate the outgroup approach to root the Bovidae family of five sampled species (Yak, Cow, Goat, Sheep and Tibetan antelope) using two outgroup species (Pig and Whale). Please download:</p><ul><li>An <a href=""http://www.iqtree.org/doc/data/bovidae_outgroup.phy"">input DNA alignment file</a> for these 7 species.</li><li>An <a href=""http://www.iqtree.org/doc/data/bovidae.nex"">input partition file</a> that defines 52 genes in this alignment. This is a subset of the mammal dataset (<a href=""https://doi.org/10.1016/j.dib.2018.04.094"">Wu et al., 2018</a>).</li></ul><blockquote><p>Choosing a “good” outgroup is an entire topic on its own. In generally, the outgroup must contain taxa that do not belong to the ingroup but are evolutionarily close enough to the ingroup taxa.</p></blockquote><p>To infer an unrooted tree, run:</p><pre><code>iqtree2 -s bovidae_outgroup.phy -p bovidae.nex -B 1000 -T AUTO --prefix rev_dna_outg
</code></pre><p>that will invoke the ultrafast bootstrap with 1000 replicates (<code>-B 1000</code>), detect the optimal number of threads (<code>-T AUTO</code>) and write all output files with the prefix <code>rev_dna_outg</code>.</p><p>The input alignment contains protein-coding genes. We can ask IQ-TREE to translate the alignment into protein sequences using the standard genetic code (<code>-st NT2AA</code>) and perform an amino-acid analysis on the translated alignment with:</p><pre><code>iqtree2 -s bovidae_outgroup.phy -p bovidae.nex -B 1000 -T AUTO -st NT2AA --prefix rev_aa_outg
</code></pre><p>where setting the prefix to <code>rev_aa_outg</code> avoids file overwriting with the previous run. The resulting tree may now look like (extracted from <code>rev_aa_outg.iqtree</code>):</p><pre><code>NOTE: Tree is UNROOTED although outgroup taxon 'Yak' is drawn at root
Numbers in parentheses are  ultrafast bootstrap support (%)

+--Yak
|
+--Cow
|
|          +--Goat
|       +--| (100)
|       |  +--Sheep
|   +---| (100)
|   |   +---Tibetan_antelope
+---| (100)
    |                      +-------------------------------Wild_pig
    +----------------------| (100)
                           +-------------------Minke_whale
</code></pre><p>You can open <code>rev_aa_outg.treefile</code> in a tree viewer software (e.g. FigTree) and re-root the tree on the branch separating the outgroup (<code>Wild_pig</code> and <code>Minke_whale</code>) from the remaining ingroup to obtain an outgroup-rooted tree.</p><p>Finally, if you want you can also perform a non-partition analysis by removing the option <code>-p</code>.</p></classify1>",Inferring unrooted tree with outgroup,87.0,87.0,"An input DNA alignment file for these 7 species.An input partition file that defines 52 genes in this alignment. This is a subset of the mammal dataset (Wu et al., 2018)."
"<classify1 id=""1""><h2 id=""inferring-rooted-trees-without-outgroup"">Inferring rooted trees without outgroup</h2><p>We will now infer a rooted tree using non-reversible models. Please download:</p><ul><li>An <a href=""http://www.iqtree.org/doc/data/bovidae.phy"">input DNA alignment file</a> for 5 ingroup species (Yak, Cow, Goat, Sheep and Tibetan antelope). This is a sub-alignment of the alignment above. We can re-use the same partition file.</li></ul><p>To speed up the analysis, we will perform two steps. The first step is the same as the run above to infer an unrooted tree using reversible models:</p><pre><code>iqtree2 -s bovidae.phy -p bovidae.nex -B 1000 -T AUTO --prefix rev_dna
</code></pre><p>This run will also write the best partitioning scheme to <code>rev_dna.best_scheme.nex</code> file. In the second step, we will re-use this best scheme but replace the substitution model with the most general non-reversible DNA model, 12.12 or UNREST (see <a href=""http://www.iqtree.org/doc/Substitution-Models#lie-markov-models"">this doc</a>) to obtain a rooted tree:</p><pre><code>iqtree2 -s bovidae.phy -p rev_dna.best_scheme.nex --model-joint 12.12 -B 1000 -T AUTO --prefix nonrev_dna
</code></pre><p>The option <code>--model-joint 12.12</code> tells IQ-TREE use a linked substitution model 12.12 across all partitions. This is to avoid potential over-parameterization as this is very parameter-rich model with 12 parameters.</p><p>The resulting tree extracted from .iqtree file might look like this:</p><pre><code>NOTE: Tree is ROOTED at virtual root '__root__'
Numbers in parentheses are  ultrafast bootstrap support (%)

       +---Yak
+------| (72)
|      |                                       +----------Goat
|      |                                   +---| (100)
|      |                                   |   +----------Sheep
|      +-----------------------------------| (95)
|                                          +-------------Tibetan_antelope
|
+**Cow
|
+**__root__
</code></pre><p>(You can better visualize the .treefile in a tree viewer software).</p><p>This run will write an additional tree file <code>nonrev_dna.rootstrap.nex</code> with <em>rootstrap</em> support values (see box below for definition) annotated on every branch of the tree. If you open this file in FigTree it may look like this (click on “Branch Labels” and choose <code>rootstrap</code> for “Display” as shown in the figure):</p><p><img alt=""Rooted tree with rootstrap supports for DNA"" src=""./Rooting phylogenies_files/nonrev_dna.png""/></p><p>It shows that the tree might be rooted in the branch leading to <code>Cow</code> with a rootstrap support of 72%, which is rather low. The 2nd best branch separating Cow and Yak from the rest has a rootstrap support of 17.9%. So with this dataset the DNA model cannot reliably tell where the root position is, but at least provides some candidates.</p><blockquote><p><strong>Rootstrap</strong>: To compute rootstrap supports, we conduct a bootstrap analysis to obtain a number of rooted bootstrap trees using non-reversible models. We define the rootstrap support for each branch in the maximum likelihood (ML) tree, as the proportion of rooted bootstrap trees that have the root on that branch. The rootstrap support values are computed for all the branches including external branches. The sum of the rootstrap support values along the tree are always smaller than or equal to one. A sum that is smaller than one can occur when one or more bootstrap replicates are rooted on a branch that does not occur in the ML tree.</p></blockquote><p>We will now try the amino-acid model to see if that helps. We again use <code>-st NT2AA</code> option to conveniently perform this analysis:</p><pre><code># step 1: infer unrooted tree with reversible models
iqtree2 -s bovidae.phy -p bovidae.nex -B 1000 -T AUTO -st NT2AA --prefix rev_aa

# step 2: infer rooted tree with linked non-reversible models
iqtree2 -s bovidae.phy -p rev_aa.best_scheme.nex --model-joint NONREV -B 1000 -T AUTO -st NT2AA --prefix nonrev_aa
</code></pre><p>The option <code>--model-joint NONREV</code> tells IQ-TREE to use the most general amino-acid model NONREV and to link the NONREV model parameters across all partitions: NONREV has 379 parameters and linking them across partitions will avoid over-parameterization. The tree extracted from <code>nonrev_aa.iqtree</code> file now may look like:</p><pre><code>NOTE: Tree is ROOTED at virtual root '__root__'
Numbers in parentheses are  ultrafast bootstrap support (%)

                                 +------------Yak
+--------------------------------| (100)
|                                +----------------Cow
|
|                                   +-------------------Goat
|                          +--------| (100)
|                          |        +---------------------Sheep
+--------------------------| (100)
|                          +-----------------------------Tibetan_antelope
|
+**__root__
</code></pre><p>Interestingly, the amino-acid model suggests a different root position compared with the DNA model. But this position agrees with the outgroup rooting approach. And the tree <code>nonrev_aa.rootstrap.nex</code> with rootstrap supports look like:</p><p><img alt=""Rooted tree with rootstrap supports using amino-acid nonreversible model"" src=""./Rooting phylogenies_files/nonrev_aa.png""/></p><p>That means, the branch separating Yak and Cow from the rest receives a very high rootstrap support of 99.9%. Therefore, the amino-acid model seems to have a much higher power to detect the root, compared with the DNA model.</p></classify1>",Inferring rooted trees without outgroup,88.0,88.0,"An input DNA alignment file for 5 ingroup species (Yak, Cow, Goat, Sheep and Tibetan antelope). This is a sub-alignment of the alignment above. We can re-use the same partition file."
"<classify1 id=""2""><h2 id=""testing-root-positions"">Testing root positions</h2><p>The rootstrap introduced above is one way to measure our confidence in the root placement, but it is not a statistical test. Alternatively, we can apply the <a href=""http://www.iqtree.org/doc/Advanced-Tutorial#tree-topology-tests"">tree topology tests</a> to compare the log-likelihoods of the trees being rooted on every branch of the ML tree. IQ-TREE v2.1.3 provides a convenient option <code>--root-test</code> that will re-root the tree on every branch and perform the test for you. So you can run:</p><pre><code>iqtree2 -s bovidae.phy -p rev_aa.best_scheme.nex --model-joint NONREV -st NT2AA --root-test -zb 1000 -au -te nonrev_aa.treefile --prefix nonrev_aa_test
</code></pre><p><code>-zb 1000 -au</code> is to perform several tree topology tests including the approximately-unbiased (AU) test for the tree found above (<code>-te nonrev_aa.treefile</code>). This run will write a file <code>nonrev_aa_test.roottest.csv</code> which might look like:</p><pre><code># Test results for rooting positions on every branch
# This file can be read in MS Excel or in R with command:
#    dat=read.csv('nonrev_aa_test.roottest.csv',comment.char='#')
# Columns are comma-separated with following meanings:
#    ID:      Branch ID
#    logL:    Log-likelihood of the tree rooted at this branch
#    deltaL:  logL difference from the maximal logl
#    bp-RELL: bootstrap proportion using RELL method (Kishino et al. 1990)
#    p-KH:    p-value of one sided Kishino-Hasegawa test (1989)
#    p-SH:    p-value of Shimodaira-Hasegawa test (2000)
#    c-ELW:   Expected Likelihood Weight (Strimmer &amp; Rambaut 2002)
#    p-AU:    p-value of approximately unbiased (AU) test (Shimodaira, 2002)
ID,logL,deltaL,bp-RELL,p-KH,p-SH,c-ELW,p-AU
1,-90388.66044,0,0.983,0.96,1,0.9695602131,0.9975595105
8,-90401.6833,13.02286164,0.005,0.04,0.19,0.01262108065,0.00558089101
5,-90401.68371,13.0232665,0.01,0.04,0.19,0.01262245766,0.006374455939
3,-90410.10499,21.44455589,0.002,0.016,0.104,0.002397842346,0.001014359781
2,-90410.1084,21.44796542,0,0.016,0.104,0.002389013519,0.0008999725939
6,-90413.04441,24.38397245,0,0.005,0.059,0.0002047272296,0.0004975092439
7,-90413.04797,24.38753181,0,0.005,0.059,0.0002046654974,0.0005061888325
</code></pre><p>The branches are sorted by log-likelihoods in descending order. The last column (p-AU) shows the p-values of the AU test. The branch ID 1 has an AU p-value of 0.9975595105, whereas all other branches has p-values &lt; 0.01. To associate branch ID you can return to the FigTree window for <code>nonrev_aa.rootstrap.nex</code> file and select “Display” to “id” in the “Branch Labels” tab.</p><p>The conclusion from this analysis: we can reject all rooting positions on branches other than branch ID 1, which agrees with the rootstrap measure.</p><p>TIP: These options <code>--root-test -zb 1000 -au</code> can be combined with the rootstrap run in the previous section to calculate the rootstrap support values and the rooting test p-values in one single analysis.</p><div class=""spacing""></div></classify1>",Testing root positions,89.0,89.0,"iqtree2 -s bovidae.phy -p rev_aa.best_scheme.nex --model-joint NONREV -st NT2AA --root-test -zb 1000 -au -te nonrev_aa.treefile --prefix nonrev_aa_test
"
"<classify1 id=""0""><h2 id=""dna-models"">DNA models</h2><div class=""hline""></div><h3 id=""base-substitution-rates"">Base substitution rates</h3><p>IQ-TREE includes all common DNA models (ordered by complexity):</p><table><thead><tr><th>Model</th><th>df</th><th>Explanation</th><th>Code</th></tr></thead><tbody><tr><td>JC or JC69</td><td>0</td><td>Equal substitution rates and equal base frequencies (<a href=""http://doi.org/10.1016/B978-1-4832-3211-9.50009-7"">Jukes and Cantor, 1969</a>).</td><td>000000</td></tr><tr><td>F81</td><td>3</td><td>Equal rates but unequal base freq. (<a href=""https://doi.org/10.1007%2FBF01734359"">Felsenstein, 1981</a>).</td><td>000000</td></tr><tr><td>K80 or K2P</td><td>1</td><td>Unequal transition/transversion rates and equal base freq. (<a href=""https://doi.org/10.1007%2FBF01731581"">Kimura, 1980</a>).</td><td>010010</td></tr><tr><td>HKY or HKY85</td><td>4</td><td>Unequal transition/transversion rates and unequal base freq. (<a href=""https://dx.doi.org/10.1007%2FBF02101694"">Hasegawa, Kishino and Yano, 1985</a>).</td><td>010010</td></tr><tr><td>TN or TN93</td><td>5</td><td>Like <code>HKY</code> but unequal purine/pyrimidine rates (<a href=""http://mbe.oxfordjournals.org/cgi/content/abstract/10/3/512"">Tamura and Nei, 1993</a>).</td><td>010020</td></tr><tr><td>TNe</td><td>2</td><td>Like <code>TN</code> but equal base freq.</td><td>010020</td></tr><tr><td>K81 or K3P</td><td>2</td><td>Three substitution types model and equal base freq. (<a href=""https://doi.org/10.1073/pnas.78.1.454"">Kimura, 1981</a>).</td><td>012210</td></tr><tr><td>K81u</td><td>5</td><td>Like <code>K81</code> but unequal base freq.</td><td>012210</td></tr><tr><td>TPM2</td><td>2</td><td>AC=AT, AG=CT, CG=GT and equal base freq.</td><td>010212</td></tr><tr><td>TPM2u</td><td>5</td><td>Like <code>TPM2</code> but unequal base freq.</td><td>010212</td></tr><tr><td>TPM3</td><td>2</td><td>AC=CG, AG=CT, AT=GT and equal base freq.</td><td>012012</td></tr><tr><td>TPM3u</td><td>5</td><td>Like <code>TPM3</code> but unequal base freq.</td><td>012012</td></tr><tr><td>TIM</td><td>6</td><td>Transition model, AC=GT, AT=CG and unequal base freq.</td><td>012230</td></tr><tr><td>TIMe</td><td>3</td><td>Like <code>TIM</code> but equal base freq.</td><td>012230</td></tr><tr><td>TIM2</td><td>6</td><td>AC=AT, CG=GT and unequal base freq.</td><td>010232</td></tr><tr><td>TIM2e</td><td>3</td><td>Like <code>TIM2</code> but equal base freq.</td><td>010232</td></tr><tr><td>TIM3</td><td>6</td><td>AC=CG, AT=GT and unequal base freq.</td><td>012032</td></tr><tr><td>TIM3e</td><td>3</td><td>Like <code>TIM3</code> but equal base freq.</td><td>012032</td></tr><tr><td>TVM</td><td>7</td><td>Transversion model, AG=CT and unequal base freq.</td><td>012314</td></tr><tr><td>TVMe</td><td>4</td><td>Like <code>TVM</code> but equal base freq.</td><td>012314</td></tr><tr><td>SYM</td><td>5</td><td>Symmetric model with unequal rates but equal base freq. (<a href=""https://doi.org/10.1007/BF00160155"">Zharkikh, 1994</a>).</td><td>012345</td></tr><tr><td>GTR</td><td>8</td><td>General time reversible model with unequal rates and unequal base freq. (<a href=""http://www.damtp.cam.ac.uk/user/st321/CV_&amp;_Publications_files/STpapers-pdf/T86.pdf"">Tavare, 1986</a>).</td><td>012345</td></tr></tbody></table><p>The last column <code>Code</code> is a 6-digit code defining the equality constraints for 6 <em>relative</em> substitution rates: A-C, A-G, A-T, C-G, C-T and G-T. <code>010010</code> means that A-G rate is equal to C-T rate (corresponding to <code>1</code> in the code) and the remaining four substitution rates are equal (corresponding to <code>0</code> in the code). Thus, <code>010010</code> is equivalent to K80 or HKY model (depending on whether base frequencies are equal or not). <code>012345</code> is equivalent to GTR or SYM model as there is no restriction defined by such 6-digit code.</p><p>Moreover, IQ-TREE supports arbitrarily restricted DNA model via a 6-digit code, e.g. with option <code>-m 012012+G</code>.</p><blockquote><p><strong>NOTE</strong>: The digits in the codes do not necessarily have to have the same order as above. That means ‘101101’ describes the same matrix as ‘010010’. The last rate, which corresponds to G-T, (and all rates with the same digit) is always set equal to 1.0 for convenience because the rates are relative.</p></blockquote><p>If users want to fix model parameters, append the model name with a curly bracket <code>{</code>, followed by the comma-separated rate parameters, and a closing curly bracket <code>}</code>. For example, <code>GTR{1.0,2.0,1.5,3.7,2.8}</code> specifies 6 substitution rates A-C=1.0, A-G=2.0, A-T=1.5, C-G=3.7, C-T=2.8 and G-T=1.0.</p><p>Another example is for model <code>TIM2</code> that has the 6-digit code <code>010232</code>. Thus, <code>TIM2{4.39,5.30,12.1}</code> means that A-C=A-T=4.39 (coded <code>0</code>), A-G=5.30 (coded <code>1</code>), C-T=12.1 (coded <code>3</code>) and C-G=G-T=1.0 (coded <code>2</code>). This is, in turn, equivalent to specifying <code>GTR{4.39,5.30,4.39,1.0,12.1}</code>.</p><h3 id=""base-frequencies"">Base frequencies</h3><p>Users can specify three different kinds of base frequencies:</p><table><thead><tr><th>FreqType</th><th>Explanation</th></tr></thead><tbody><tr><td>+F</td><td>Empirical base frequencies. This is the default if the model has unequal base freq.</td></tr><tr><td>+FQ</td><td>Equal base frequencies.</td></tr><tr><td>+FO</td><td>Optimized base frequencies by maximum-likelihood.</td></tr></tbody></table><p>For example, <code>GTR+FO</code> optimizes base frequencies by ML whereas <code>GTR+F</code> (default) counts base frequencies directly from the alignment.</p><p>Finally, users can fix base frequencies with e.g. <code>GTR+F{0.1,0.2,0.3,0.4}</code> to fix the corresponding frequencies of A, C, G and T (must sum up to 1.0).</p><h3 id=""lie-markov-models"">Lie Markov models</h3><p>Starting with version 1.6, IQ-TREE supports a series of Lie Markov models (<a href=""https://doi.org/10.1093/sysbio/syv021"">Woodhams et al., 2015</a>), many of which are non-reversible models. Lie Markov models have a consistent property, which is lacking in other common models such as GTR. The following table shows the list of all Lie Markov models (the number before <code>.</code> in the name shows the number of parameters of the model):</p><table><thead><tr><th>Model</th><th>Rev?</th><th>Freq</th><th>Note</th></tr></thead><tbody><tr><td>1.1</td><td>Yes</td><td>0</td><td>equiv. to JC</td></tr><tr><td>2.2b</td><td>Yes</td><td>0</td><td>equiv. to K2P</td></tr><tr><td>3.3a</td><td>Yes</td><td>0</td><td>equiv. to K3P</td></tr><tr><td>3.3b</td><td>No</td><td>0</td><td> </td></tr><tr><td>3.3c</td><td>Yes</td><td>0</td><td>equiv. to TNe</td></tr><tr><td>3.4</td><td>Yes</td><td>1</td><td> </td></tr><tr><td>4.4a</td><td>Yes</td><td>3</td><td>equiv. to F81</td></tr><tr><td>4.4b</td><td>Yes</td><td>1</td><td> </td></tr><tr><td>4.5a</td><td>No</td><td>1</td><td> </td></tr><tr><td>4.5b</td><td>No</td><td>1</td><td> </td></tr><tr><td>5.6a</td><td>No</td><td>0</td><td> </td></tr><tr><td>5.6b</td><td>No</td><td>3</td><td> </td></tr><tr><td>5.7a</td><td>No</td><td>2</td><td> </td></tr><tr><td>5.7b</td><td>No</td><td>0</td><td> </td></tr><tr><td>5.7c</td><td>No</td><td>0</td><td> </td></tr><tr><td>5.11a</td><td>No</td><td>2</td><td> </td></tr><tr><td>5.11b</td><td>No</td><td>0</td><td> </td></tr><tr><td>5.11c</td><td>No</td><td>0</td><td> </td></tr><tr><td>5.16</td><td>No</td><td>1</td><td> </td></tr><tr><td>6.6</td><td>No</td><td>1</td><td>equiv. to STRSYM (strand symmetric model)</td></tr><tr><td>6.7a</td><td>No</td><td>3</td><td>F81+K3P</td></tr><tr><td>6.7b</td><td>No</td><td>3</td><td> </td></tr><tr><td>6.8a</td><td>No</td><td>3</td><td> </td></tr><tr><td>6.8b</td><td>No</td><td>1</td><td> </td></tr><tr><td>6.17a</td><td>No</td><td>1</td><td> </td></tr><tr><td>6.17b</td><td>No</td><td>1</td><td> </td></tr><tr><td>8.8</td><td>No</td><td>3</td><td> </td></tr><tr><td>8.10a</td><td>No</td><td>3</td><td> </td></tr><tr><td>8.10b</td><td>No</td><td>1</td><td> </td></tr><tr><td>8.16</td><td>No</td><td>3</td><td> </td></tr><tr><td>8.17</td><td>No</td><td>3</td><td> </td></tr><tr><td>8.18</td><td>No</td><td>3</td><td> </td></tr><tr><td>9.20a</td><td>No</td><td>2</td><td> </td></tr><tr><td>9.20b</td><td>No</td><td>0</td><td>Doubly stochastic</td></tr><tr><td>10.12</td><td>No</td><td>3</td><td> </td></tr><tr><td>10.34</td><td>No</td><td>3</td><td> </td></tr><tr><td>12.12</td><td>No</td><td>3</td><td>equiv. to UNREST (unrestricted model)</td></tr></tbody></table><p>Column <strong>Rev?</strong> shows whether the model is reversible or not. Column <strong>Freq</strong> shows the number of free base frequencies. 0 means equal base frequency; 1 means f(A)=f(G) and f(C)=f(T); 2 means f(A)+f(G)=0.5=f(C)+f(T); 3 means unconstrained frequencies.</p><p>All Lie Markov models can have one of the following prefices:</p><table><thead><tr><th>Prefix</th><th>Meaning</th></tr></thead><tbody><tr><td>RY</td><td>purine-pyrimidine pairing (default)</td></tr><tr><td>WS</td><td>weak-strong pairing</td></tr><tr><td>MK</td><td>aMino-Keto pairing</td></tr></tbody></table></classify1>",DNA models,90.0,90.0,Base substitution rates
"<classify1 id=""1""><h2 id=""protein-models"">Protein models</h2><div class=""hline""></div><h3 id=""amino-acid-exchange-rate-matrices"">Amino-acid exchange rate matrices</h3><p>IQ-TREE supports all common empirical amino-acid exchange rate matrices (alphabetical order):</p><table><thead><tr><th>Model</th><th>Region</th><th>Explanation</th></tr></thead><tbody><tr><td>Blosum62</td><td>nuclear</td><td>BLOcks SUbstitution Matrix (<a href=""https://dx.doi.org/10.1073%2Fpnas.89.22.10915"">Henikoff and Henikoff, 1992</a>). Note that <code>BLOSUM62</code> is not recommended for phylogenetic analysis as it was designed mainly for sequence alignments.</td></tr><tr><td>cpREV</td><td>chloroplast</td><td>chloroplast matrix (<a href=""https://doi.org/10.1007/s002399910038"">Adachi et al., 2000</a>).</td></tr><tr><td>Dayhoff</td><td>nuclear</td><td>General matrix (<a href=""http://compbio.berkeley.edu/class/c246/Reading/dayhoff-1978-apss.pdf"">Dayhoff et al., 1978</a>).</td></tr><tr><td>DCMut</td><td>nuclear</td><td>Revised <code>Dayhoff</code> matrix (<a href=""https://doi.org/10.1093/molbev/msi005"">Kosiol and Goldman, 2005</a>).</td></tr><tr><td>FLU</td><td>viral</td><td>Influenza virus (<a href=""https://doi.org/10.1186/1471-2148-10-99"">Dang et al., 2010</a>).</td></tr><tr><td>HIVb</td><td>viral</td><td>HIV between-patient matrix HIV-B<sub>m</sub> (<a href=""https://dx.doi.org/10.1371/journal.pone.0000503"">Nickle et al., 2007</a>).</td></tr><tr><td>HIVw</td><td>viral</td><td>HIV within-patient matrix HIV-W<sub>m</sub> (<a href=""https://dx.doi.org/10.1371/journal.pone.0000503"">Nickle et al., 2007</a>).</td></tr><tr><td>JTT</td><td>nuclear</td><td>General matrix (<a href=""https://dx.doi.org/10.1093%2Fbioinformatics%2F8.3.275"">Jones et al., 1992</a>).</td></tr><tr><td>JTTDCMut</td><td>nuclear</td><td>Revised <code>JTT</code> matrix (<a href=""https://doi.org/10.1093/molbev/msi005"">Kosiol and Goldman, 2005</a>).</td></tr><tr><td>LG</td><td>nuclear</td><td>General matrix (<a href=""https://doi.org/10.1093/molbev/msn067"">Le and Gascuel, 2008</a>).</td></tr><tr><td>mtART</td><td>mitochondrial</td><td>Mitochondrial Arthropoda (<a href=""https://doi.org/10.1093/molbev/msl136"">Abascal et al., 2007</a>).</td></tr><tr><td>mtMAM</td><td>mitochondrial</td><td>Mitochondrial Mammalia (<a href=""http://mbe.oxfordjournals.org/content/15/12/1600.abstract"">Yang et al., 1998</a>).</td></tr><tr><td>mtREV</td><td>mitochondrial</td><td>Mitochondrial Vertebrate (<a href=""https://doi.org/10.1007/BF02498640"">Adachi and Hasegawa, 1996</a>).</td></tr><tr><td>mtZOA</td><td>mitochondrial</td><td>Mitochondrial Metazoa (Animals) (<a href=""https://doi.org/10.1016/j.ympev.2009.01.011"">Rota-Stabelli et al., 2009</a>).</td></tr><tr><td>mtMet</td><td>mitochondrial</td><td>Mitochondrial Metazoa (<a href=""https://doi.org/10.1186/s12862-017-0987-y"">Vinh et al., 2017</a>).</td></tr><tr><td>mtVer</td><td>mitochondrial</td><td>Mitochondrial Vertebrate (<a href=""https://doi.org/10.1186/s12862-017-0987-y"">Vinh et al., 2017</a>).</td></tr><tr><td>mtInv</td><td>mitochondrial</td><td>Mitochondrial Inverterbrate (<a href=""https://doi.org/10.1186/s12862-017-0987-y"">Vinh et al., 2017</a>).</td></tr><tr><td>Poisson</td><td>none</td><td>Equal amino-acid exchange rates and frequencies.</td></tr><tr><td>PMB</td><td>nuclear</td><td>Probability Matrix from Blocks, revised <code>BLOSUM</code> matrix (<a href=""https://doi.org/10.1089/106652703322756195"">Veerassamy et al., 2004</a>).</td></tr><tr><td>rtREV</td><td>viral</td><td>Retrovirus (<a href=""https://doi.org/10.1007/s00239-001-2304-y"">Dimmic et al., 2002</a>).</td></tr><tr><td>VT</td><td>nuclear</td><td>General ‘Variable Time’ matrix (<a href=""https://doi.org/10.1089/10665270050514918"">Mueller and Vingron, 2000</a>).</td></tr><tr><td>WAG</td><td>nuclear</td><td>General matrix (<a href=""https://doi.org/10.1093/oxfordjournals.molbev.a003851"">Whelan and Goldman, 2001</a>).</td></tr><tr><td>GTR20</td><td>general</td><td>General time reversible models with 190 rate parameters. <em>WARNING: Be careful when using this parameter-rich model as parameter estimates might not be stable, especially when not having enough phylogenetic information (e.g. not long enough alignments).</em></td></tr></tbody></table><h3 id=""protein-mixture-models"">Protein mixture models</h3><p>IQ-TREE also supports a series of protein mixture models:</p><table><thead><tr><th>Model</th><th>Explanation</th></tr></thead><tbody><tr><td>C10 to C60</td><td>10, 20, 30, 40, 50, 60-profile mixture models (<a href=""https://doi.org/10.1093/bioinformatics/btn445"">Le et al., 2008a</a>) as variants of the CAT model (<a href=""https://doi.org/10.1093/molbev/msh112"">Lartillot and Philippe, 2004</a>) for ML. Note that these models assume <code>Poisson</code> AA replacement and implicitly include a <a href=""http://www.iqtree.org/doc/Substitution-Models#rate-heterogeneity-across-sites"">Gamma rate heterogeneity among sites</a>.</td></tr><tr><td>EX2</td><td>Two-matrix model for exposed/buried AA sites (<a href=""https://doi.org/10.1098/rstb.2008.0180"">Le et al., 2008b</a>).</td></tr><tr><td>EX3</td><td>Three-matrix model for highly exposed/intermediate/buried AA sites (<a href=""https://doi.org/10.1098/rstb.2008.0180"">Le et al., 2008b</a>).</td></tr><tr><td>EHO</td><td>Three-matrix model for extended/helix/other sites (<a href=""https://doi.org/10.1098/rstb.2008.0180"">Le et al., 2008b</a>).</td></tr><tr><td>UL2, UL3</td><td>Unsupervised-learning variants of <code>EX2</code> and <code>EX3</code>, respectively.</td></tr><tr><td>EX_EHO</td><td>Six-matrix model combining <code>EX2</code> and <code>EHO</code> (<a href=""https://doi.org/10.1093/sysbio/syq002"">Le and Gascuel, 2010</a>).</td></tr><tr><td>LG4M</td><td>Four-matrix model fused with <a href=""http://www.iqtree.org/doc/Substitution-Models#rate-heterogeneity-across-sites"">Gamma rate heterogeneity</a> (<a href=""https://doi.org/10.1093/molbev/mss112"">Le et al., 2012</a>).</td></tr><tr><td>LG4X</td><td>Four-matrix model fused with <a href=""http://www.iqtree.org/doc/Substitution-Models#rate-heterogeneity-across-sites"">FreeRate heterogeneity</a> (<a href=""https://doi.org/10.1093/molbev/mss112"">Le et al., 2012</a>).</td></tr><tr><td>CF4</td><td>Five-profile mixture model (<a href=""https://doi.org/10.1186/1471-2148-8-331"">Wang et al., 2008</a>).</td></tr></tbody></table><p>One can even combine a protein matrix with a profile mixture model like:</p><ul><li><code>LG+C20</code>: Applying <code>LG</code> matrix instead of <code>Poisson</code> for all 20 classes of AA profiles and a Gamma rate heterogeneity.</li><li><code>LG+C20+F</code>: Applying <code>LG</code> matrix for 20 classes plus the 21th class of empirical AA profile (counted from the current data) and Gamma rate heterogeneity.</li><li><code>JTT+CF4+G</code>: Applying <code>JTT</code> matrix for all 5 classes of AA profiles and Gamma rate heteorogeneity.</li></ul><p>Moreover, one can override the Gamma rate by FreeRate heterogeneity:</p><ul><li><code>LG+C20+R4</code>: Like <code>LG+C20</code> but replace Gamma by FreeRate heterogeneity.</li></ul><h3 id=""user-defined-empirical-protein-models"">User-defined empirical protein models</h3><p>If the matrix name does not match any of the above listed models, IQ-TREE assumes that it is a file containing AA exchange rates and frequencies in PAML format. It contains the lower diagonal part of the matrix and 20 AA frequencies, e.g.:</p><pre><code>0.425093 
0.276818 0.751878 
0.395144 0.123954 5.076149 
2.489084 0.534551 0.528768 0.062556 
0.969894 2.807908 1.695752 0.523386 0.084808 
1.038545 0.363970 0.541712 5.243870 0.003499 4.128591 
2.066040 0.390192 1.437645 0.844926 0.569265 0.267959 0.348847 
0.358858 2.426601 4.509238 0.927114 0.640543 4.813505 0.423881 0.311484 
0.149830 0.126991 0.191503 0.010690 0.320627 0.072854 0.044265 0.008705 0.108882 
0.395337 0.301848 0.068427 0.015076 0.594007 0.582457 0.069673 0.044261 0.366317 4.145067 
0.536518 6.326067 2.145078 0.282959 0.013266 3.234294 1.807177 0.296636 0.697264 0.159069 0.137500 
1.124035 0.484133 0.371004 0.025548 0.893680 1.672569 0.173735 0.139538 0.442472 4.273607 6.312358 0.656604 
0.253701 0.052722 0.089525 0.017416 1.105251 0.035855 0.018811 0.089586 0.682139 1.112727 2.592692 0.023918 1.798853 
1.177651 0.332533 0.161787 0.394456 0.075382 0.624294 0.419409 0.196961 0.508851 0.078281 0.249060 0.390322 0.099849 0.094464 
4.727182 0.858151 4.008358 1.240275 2.784478 1.223828 0.611973 1.739990 0.990012 0.064105 0.182287 0.748683 0.346960 0.361819 1.338132 
2.139501 0.578987 2.000679 0.425860 1.143480 1.080136 0.604545 0.129836 0.584262 1.033739 0.302936 1.136863 2.020366 0.165001 0.571468 6.472279 
0.180717 0.593607 0.045376 0.029890 0.670128 0.236199 0.077852 0.268491 0.597054 0.111660 0.619632 0.049906 0.696175 2.457121 0.095131 0.248862 0.140825 
0.218959 0.314440 0.612025 0.135107 1.165532 0.257336 0.120037 0.054679 5.306834 0.232523 0.299648 0.131932 0.481306 7.803902 0.089613 0.400547 0.245841 3.151815 
2.547870 0.170887 0.083688 0.037967 1.959291 0.210332 0.245034 0.076701 0.119013 10.649107 1.702745 0.185202 1.898718 0.654683 0.296501 0.098369 2.188158 0.189510 0.249313 

0.079066 0.055941 0.041977 0.053052 0.012937 0.040767 0.071586 0.057337 0.022355 0.062157 0.099081 0.064600 0.022951 0.042302 0.044040 0.061197 0.053287 0.012066 0.034155 0.069147 
</code></pre><p>(This is an example of an LG matrix taken from <a href=""http://abacus.gene.ucl.ac.uk/software/paml.html"">PAML package</a>). Note that the amino-acid order in this file is:</p><pre><code> A   R   N   D   C   Q   E   G   H   I   L   K   M   F   P   S   T   W   Y   V
Ala Arg Asn Asp Cys Gln Glu Gly His Ile Leu Lys Met Phe Pro Ser Thr Trp Tyr Val
</code></pre><h3 id=""amino-acid-frequencies"">Amino-acid frequencies</h3><p>By default, AA frequencies are given by the model. Users can change this with:</p><table><thead><tr><th>FreqType</th><th>Explanation</th></tr></thead><tbody><tr><td>+F</td><td>empirical AA frequencies from the data.</td></tr><tr><td>+FO</td><td>ML optimized AA frequencies from the data.</td></tr><tr><td>+FQ</td><td>Equal AA frequencies.</td></tr></tbody></table><p>Users can also specify AA frequencies with, e.g.:</p><pre><code>+F{0.079066,0.055941,0.041977,0.053052,0.012937,0.040767,0.071586,0.057337,0.022355,0.062157,0.099081,0.064600,0.022951,0.042302,0.044040,0.061197,0.053287,0.012066,0.034155,0.069147}
</code></pre><p>(Example corresponds to the AA frequencies of the LG matrix).</p></classify1>",Protein models,91.0,91.0,Amino-acid exchange rate matrices
"<classify1 id=""2""><h2 id=""codon-models"">Codon models</h2><div class=""hline""></div><p>To apply a codon model one should use the option <code>-st CODON</code> to tell IQ-TREE that the alignment contains protein coding sequences (otherwise, IQ-TREE thinks that it contains DNA sequences and will apply DNA models). This implicitly applies the standard genetic code. You can change to an other genetic code by appending the appropriate ID to the <code>CODON</code> keyword:</p><table><thead><tr><th>Code</th><th>Genetic code meaning</th></tr></thead><tbody><tr><td>CODON1</td><td>The Standard Code (same as <code>-st CODON</code>)</td></tr><tr><td>CODON2</td><td>The Vertebrate Mitochondrial Code</td></tr><tr><td>CODON3</td><td>The Yeast Mitochondrial Code</td></tr><tr><td>CODON4</td><td>The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code</td></tr><tr><td>CODON5</td><td>The Invertebrate Mitochondrial Code</td></tr><tr><td>CODON6</td><td>The Ciliate, Dasycladacean and Hexamita Nuclear Code</td></tr><tr><td>CODON9</td><td>The Echinoderm and Flatworm Mitochondrial Code</td></tr><tr><td>CODON10</td><td>The Euplotid Nuclear Code</td></tr><tr><td>CODON11</td><td>The Bacterial, Archaeal and Plant Plastid Code</td></tr><tr><td>CODON12</td><td>The Alternative Yeast Nuclear Code</td></tr><tr><td>CODON13</td><td>The Ascidian Mitochondrial Code</td></tr><tr><td>CODON14</td><td>The Alternative Flatworm Mitochondrial Code</td></tr><tr><td>CODON16</td><td>Chlorophycean Mitochondrial Code</td></tr><tr><td>CODON21</td><td>Trematode Mitochondrial Code</td></tr><tr><td>CODON22</td><td>Scenedesmus obliquus Mitochondrial Code</td></tr><tr><td>CODON23</td><td>Thraustochytrium Mitochondrial Code</td></tr><tr><td>CODON24</td><td>Pterobranchia Mitochondrial Code</td></tr><tr><td>CODON25</td><td>Candidate Division SR1 and Gracilibacteria Code</td></tr></tbody></table><p>(The IDs follow the specification at <a href=""http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi"">http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</a>).</p><h3 id=""codon-substitution-rates"">Codon substitution rates</h3><p>IQ-TREE supports several codon models:</p><table><thead><tr><th>Model</th><th>Explanation</th></tr></thead><tbody><tr><td>MG</td><td>Nonsynonymous/synonymous (dn/ds) rate ratio (<a href=""http://mbe.oxfordjournals.org/content/11/5/715.abstract"">Muse and Gaut, 1994</a>).</td></tr><tr><td>MGK</td><td>Like <code>MG</code> with additional transition/transversion (ts/tv) rate ratio.</td></tr><tr><td>MG1KTS or MGKAP2</td><td>Like <code>MG</code> with a transition rate (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>MG1KTV or MGKAP3</td><td>Like <code>MG</code> with a transversion rate (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>MG2K or MGKAP4</td><td>Like <code>MG</code> with a transition rate and a transversion rate (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>GY</td><td>Nonsynonymous/synonymous and transition/transversion rate ratios (<a href=""http://mbe.oxfordjournals.org/content/11/5/725.abstract"">Goldman and Yang, 1994</a>).</td></tr><tr><td>GY1KTS or GYKAP2</td><td>Like <code>GY</code> with a transition rate (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>GY1KTV or GYKAP3</td><td>Like <code>GY</code> with a transversion rate (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>GY2K or GYKAP4</td><td>Like <code>GY</code> with a transition rate and a transversion rate (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>ECMK07 or KOSI07</td><td>Empirical codon model (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</td></tr><tr><td>ECMrest</td><td>Restricted version of <code>ECMK07</code> that allows only one nucleotide exchange.</td></tr><tr><td>ECMS05 or SCHN05</td><td>Empirical codon model (<a href=""https://doi.org/10.1186/1471-2105-6-134"">Schneider et al., 2005</a>).</td></tr></tbody></table><p>The last three models (<code>ECMK07</code>, <code>ECMrest</code> or <code>ECMS05</code>) are called <em>empirical</em> codon models, whereas the others are called <em>mechanistic</em> codon models.</p><p>Moreover, IQ-TREE supports combined empirical-mechanistic codon models using an underscore separator (<code>_</code>). For example:</p><ul><li><code>ECMK07_GY2K</code>: The combined <code>ECMK07</code> and <code>GY2K</code> model, with the rate entries being multiplication of the two corresponding rate matrices.</li></ul><p>Thus, there can be many such combinations.</p><p><strong>Starting with version 1.5.6:</strong> If the model name does not match any of the above listed models, IQ-TREE assumes that it is a file containing lower diagonal part of non-stop codon exchange rate matrix, non-stop codon frequencies and a list of non-stop codons. The rest of the file will be ignored. Example files (ECMrest.dat and ECMunrest.dat) can be downloaded from the supplementary material (<a href=""https://doi.org/10.1093/molbev/msm064"">Kosiol et al., 2007</a>).</p><blockquote><p><strong>NOTE</strong>: Branch lengths under codon models are interpreted as number of nucleotide substitutions per codon site. Thus, they are typically 3 times longer than under DNA models.</p></blockquote><h3 id=""codon-frequencies"">Codon frequencies</h3><p>IQ-TREE supports the following codon frequencies:</p><table><thead><tr><th>FreqType</th><th>Explanation</th></tr></thead><tbody><tr><td>+F</td><td>Empirical codon frequencies counted from the data.</td></tr><tr><td>+FQ</td><td>Equal codon frequencies.</td></tr><tr><td>+F1X4</td><td>Unequal nucleotide frequencies but equal nt frequencies over three codon positions.</td></tr><tr><td>+F3X4</td><td>Unequal nucleotide frequencies and unequal nt frequencies over three codon positions.</td></tr></tbody></table><p>If not specified, the default codon frequency will be <code>+F3X4</code> for <code>MG</code>-type models, <code>+F</code> for <code>GY</code>-type models and given by the model for empirical codon models.</p></classify1>",Codon models,92.0,92.0,"To apply a codon model one should use the option -st CODON to tell IQ-TREE that the alignment contains protein coding sequences (otherwise, IQ-TREE thinks that it contains DNA sequences and will apply DNA models). This implicitly applies the standard genetic code. You can change to an other genetic code by appending the appropriate ID to the CODON keyword:"
"<classify1 id=""3""><h2 id=""binary-and-morphological-models"">Binary and morphological models</h2><div class=""hline""></div><p>The binary alignments should contain state <code>0</code> and <code>1</code>, whereas for morphological data, the valid states are <code>0</code> to <code>9</code> and <code>A</code> to <code>Z</code>.</p><table><thead><tr><th>Model</th><th>Explanation</th></tr></thead><tbody><tr><td>JC2</td><td>Jukes-Cantor type model for binary data.</td></tr><tr><td>GTR2</td><td>General time reversible model for binary data.</td></tr><tr><td>MK</td><td>Jukes-Cantor type model for morphological data.</td></tr><tr><td>ORDERED</td><td>Allowing exchange of neighboring states only.</td></tr></tbody></table><p>Except for <code>GTR2</code> that has unequal state frequencies, all other models have equal state frequencies.</p><blockquote class=""tip""><p><strong>TIP</strong>: If morphological alignments do not contain constant sites (typically the case), then <a href=""http://www.iqtree.org/doc/Substitution-Models#ascertainment-bias-correction"">an ascertainment bias correction model (<code>+ASC</code>)</a> should be applied to correct the branch lengths for the absence of constant sites.</p></blockquote></classify1>",Binary and morphological models,93.0,93.0,"The binary alignments should contain state 0 and 1, whereas for morphological data, the valid states are 0 to 9 and A to Z."
"<classify1 id=""4""><h2 id=""ascertainment-bias-correction"">Ascertainment bias correction</h2><div class=""hline""></div><p>An ascertainment bias correction (<code>+ASC</code>) model (<a href=""https://doi.org/10.1080/106351501753462876"">Lewis, 2001</a>) should be applied if the alignment does not contain constant sites (such as morphological or SNPs data). For example:</p><ul><li><code>MK+ASC</code>: For morphological data.</li><li><code>GTR+ASC</code>: For SNPs data.</li></ul><p><code>+ASC</code> will correct the likelihood conditioned on variable sites. Without <code>+ASC</code>, the branch lengths might be overestimated.</p></classify1>",Ascertainment bias correction,94.0,94.0,"An ascertainment bias correction (+ASC) model (Lewis, 2001) should be applied if the alignment does not contain constant sites (such as morphological or SNPs data). For example:"
"<classify1 id=""5""><h2 id=""rate-heterogeneity-across-sites"">Rate heterogeneity across sites</h2><div class=""hline""></div><p>IQ-TREE supports all common rate heterogeneity across sites models:</p><table><thead><tr><th>RateType</th><th>Explanation</th></tr></thead><tbody><tr><td>+I</td><td>allowing for a proportion of invariable sites.</td></tr><tr><td>+G</td><td>discrete Gamma model (<a href=""https://doi.org/10.1007/BF00160154"">Yang, 1994</a>) with default 4 rate categories. The number of categories can be changed with e.g. <code>+G8</code>.</td></tr><tr><td>+I+G</td><td>invariable site plus discrete Gamma model (<a href=""http://mbe.oxfordjournals.org/content/12/4/546.abstract"">Gu et al., 1995</a>).</td></tr><tr><td>+R</td><td>FreeRate model (<a href=""http://www.genetics.org/content/139/2/993.abstract"">Yang, 1995</a>; <a href=""https://doi.org/10.1093/molbev/mss140"">Soubrier et al., 2012</a>) that generalizes the <code>+G</code> model by relaxing the assumption of Gamma-distributed rates. The number of categories can be specified with e.g. <code>+R6</code> (default 4 categories if not specified). The FreeRate model typically fits data better than the <code>+G</code> model and is recommended for analysis of large data sets.</td></tr><tr><td>+I+R</td><td>invariable site plus FreeRate model.</td></tr></tbody></table><blockquote class=""tip""><p><strong>TIP</strong>: The new ModelFinder (<code>-m MFP</code> option) tests the FreeRate model, whereas the standard procedure (<code>-m TEST</code>) does not.</p></blockquote><p>Users can fix the parameters of the model. For example, <code>+I{0.2}</code> will fix the proportion of invariable sites (pinvar) to 0.2; <code>+G{0.9}</code> will fix the Gamma shape parameter (alpha) to 0.9; <code>+I{0.2}+G{0.9}</code> will fix both pinvar and alpha. To fix the FreeRate model parameters, use the syntax <code>+Rk{w1,r1,...,wk,rk}</code> (replacing <code>k</code> with the number of categories). Here, <code>w1, ..., wk</code> are the weights and <code>r1, ..., rk</code> the rates for each category.</p><blockquote><p><strong>NOTE</strong>: For the <code>+G</code> model IQ-TREE implements the <em>mean</em> approximation approach (<a href=""https://doi.org/10.1007/BF00160154"">Yang, 1994</a>). The same is done in RAxML and PhyML. However, some programs like TREE-PUZZLE implement the <em>median</em> approximation approach, which makes the resulting log-likelihood not comparable. IQ-TREE can change to this approach via the <code>-gmedian</code> option.</p></blockquote><div class=""spacing""></div></classify1>",Rate heterogeneity across sites,95.0,95.0,IQ-TREE supports all common rate heterogeneity across sites models:
"<classify1 id=""0""><h2 id=""tree-inference"">Tree Inference</h2><div class=""hline""></div><p>Tree Inference provides the most frequently used features of IQ-TREE and allows users to carry out phylogenetic analysis on a multiple sequence alignment (MSA). In the most basic case, no more than an MSA file is required to submit the job. Without further input, IQ-TREE will run with the default parameters and auto-detect the sequence type as well as the best-fitting substitution model. Additionally, Ultrafast Bootstrap (<a href=""https://doi.org/10.1093/molbev/msx281"">Hoang et al., 2018</a>) and the SH-aLRT branch test (<a href=""https://doi.org/10.1093/sysbio/syq010"">Guindon et al., 2010</a>) will be performed.</p><p>You can either try out the web server with an example alignment by ticking the corresponding box or upload your own alignment file. By clicking on ‘Browse’ a dialog will open where you can select your MSA; the file formats Phylip, Fasta, Nexus, Clustal and MSF are supported.</p><p><img alt=""Tree Inference Tab"" src=""./Web Server Tutorial_files/tut1.png""/></p><p>After that you can submit the job. If you provide an email address, a notification will be sent to you once the job is finished. In case you don’t specify an email address, you will receive a link in the next step; you can bookmark this link to retrieve your results after the job is finished.</p></classify1>",Tree Inference,96.0,96.0,"Tree Inference provides the most frequently used features of IQ-TREE and allows users to carry out phylogenetic analysis on a multiple sequence alignment (MSA). In the most basic case, no more than an MSA file is required to submit the job. Without further input, IQ-TREE will run with the default parameters and auto-detect the sequence type as well as the best-fitting substitution model. Additionally, Ultrafast Bootstrap (Hoang et al., 2018) and the SH-aLRT branch test (Guindon et al., 2010) will be performed."
"<classify1 id=""1""><h2 id=""model-selection"">Model Selection</h2><div class=""hline""></div><p>IQ-TREE supports a wide range of substitution models for DNA, protein, codon, binary and morphological alignments. In case you do not know which model is appropriate for your data, IQ-TREE can automatically determine the best-fit model for your alignment. Use the Model Selection tab if you only want to find the best-fit model without doing tree reconstruction.</p><p><img alt=""Model Selection Tab"" src=""./Web Server Tutorial_files/tut2.png""/></p><p>Like with <a href=""http://www.iqtree.org/doc/Web-Server-Tutorial#tree-inference"">Tree Inference</a>, the only obligatory input is a multiple sequence alignment. You can either upload your own <strong>alignment file</strong> or use the <strong>example alignment</strong> to try out the web server and then <strong>submit the job</strong>.</p></classify1>",Model Selection,97.0,97.0,"IQ-TREE supports a wide range of substitution models for DNA, protein, codon, binary and morphological alignments. In case you do not know which model is appropriate for your data, IQ-TREE can automatically determine the best-fit model for your alignment. Use the Model Selection tab if you only want to find the best-fit model without doing tree reconstruction."
"<classify1 id=""2""><h2 id=""analysis-results"">Analysis Results</h2><div class=""hline""></div><p>In the tab Analysis Results you can monitor your jobs. With our example file, a run will only take a few seconds, depending on the server load. For your own alignments the CPU time limit is 24 hours. If you provided an email address when submitting the job, you will get an email once it is finished.</p><p><img alt=""Analysis Results"" src=""./Web Server Tutorial_files/tut3.png""/></p><p>Once a job is finished, you can select it by checking the corresponding box and then <strong>download the selected jobs</strong> as a zip file. This zip file will contain the results of your run, including the <strong>Run Log</strong> and the <strong>Full Result</strong> which are also accessible in the webserver.</p><table><thead><tr><th>Suffix</th><th>Explanation</th></tr></thead><tbody><tr><td><code>.iqtree</code></td><td>Full result of the run, this is the main report file</td></tr><tr><td><code>.log</code></td><td>Run log</td></tr><tr><td><code>.treefile</code></td><td>Maximum likelihood tree in NEWICK format, can be visualized with treeviewer programs</td></tr><tr><td><code>.svg</code></td><td>Graphical tree representation in SVG format, done with ete view</td></tr><tr><td><code>.pdf</code></td><td>Graphical tree representation in PDF format, done with ete view</td></tr><tr><td><code>.contree</code></td><td>Consensus tree with assigned branch supports where branch lengths are optimized on the original alignment; printed if Ultrafast Bootstrap is selected</td></tr><tr><td><code>.ckp.gz</code></td><td>Checkpoint file; included if a job was stopped because of RAM/CPU limits</td></tr></tbody></table><blockquote><p><strong>NOTE</strong>: Jobs which require more than 24 hours or 1GB RAM will be stopped. In such a case, you can download the stopped job and resume the run from the last checkpoint on your local PC as <a href=""http://www.iqtree.org/doc/Command-Reference#checkpointing-to-resume-stopped-run"">described here</a>.</p></blockquote><div class=""spacing""></div></classify1>",Analysis Results,98.0,98.0,"In the tab Analysis Results you can monitor your jobs. With our example file, a run will only take a few seconds, depending on the server load. For your own alignments the CPU time limit is 24 hours. If you provided an email address when submitting the job, you will get an email once it is finished."
